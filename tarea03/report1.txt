--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         2097152 B, 64 B, 8-way associative
Command:          ./a.out
Data file:        cachegrind.out.11514
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir             I1mr  ILmr  Dr            D1mr        DLmr        Dw            D1mw      DLmw      
--------------------------------------------------------------------------------
19,571,066,155 9,781 4,988 3,837,592,853 428,155,225 244,393,723 1,486,688,425 2,764,925 2,171,379  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir            I1mr ILmr Dr            D1mr        DLmr        Dw            D1mw      DLmw       file:function
--------------------------------------------------------------------------------
8,368,605,344   62   28 1,050,263,212 129,686,914 107,375,167 1,035,836,032         0         0  /home/renzo/repos/spack/opt/spack/linux-slackware14-core2/gcc-9.3.0/eigen-3.3.7-d3fwbpqkxuuxfzl43t63y74jaxvht3bx/include/eigen3/Eigen/src/Jacobi/Jacobi.h:Eigen::ComputationInfo Eigen::internal::computeFromTridiagonal_impl<Eigen::Matrix<double, -1, -1, 0, -1, -1>, Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, -1, 1, 0, -1, 1> >(Eigen::Matrix<double, -1, 1, 0, -1, 1>&, Eigen::Matrix<double, -1, 1, 0, -1, 1>&, long, bool, Eigen::Matrix<double, -1, -1, 0, -1, -1>&)
6,063,046,164  166   84 1,386,865,692 129,321,267   6,025,534     5,636,064         0         0  /usr/lib64/gcc/x86_64-slackware-linux/9.3.0/include/emmintrin.h:Eigen::internal::gebp_kernel<double, double, long, Eigen::internal::blas_data_mapper<double, long, 0, 0>, 4, 4, false, false>::operator()(Eigen::internal::blas_data_mapper<double, long, 0, 0> const&, double const*, double const*, long, long, long, double, long, long, long, long) [clone .constprop.0]
1,019,290,632    1    1   407,646,755  51,307,641  44,134,607   203,997,122    74,922    49,930  /usr/lib64/gcc/x86_64-slackware-linux/9.3.0/include/emmintrin.h:void Eigen::internal::outer_product_selector_run<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1, 0, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, -1, 1> const> const, Eigen::Block<Eigen::Matrix<double, -1, -1, 0, -1, -1> const, -1, 1, false> const>, Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, -1, 1> const> const, Eigen::Block<Eigen::Matrix<double, -1, -1, 0, -1, -1> const, -1, 1, false> const>, Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::DenseShape, Eigen::DenseShape, 5>::sub>(Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1, 0, -1, -1>, -1, -1, false>, -1, -1, false>&, Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, -1, 1> const> const, Eigen::Block<Eigen::Matrix<double, -1, -1, 0, -1, -1> const, -1, 1, false> const> const&, Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, -1>, 0, Eigen::Stride<0, 0> > const&, Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, -1, 1> const> const, Eigen::Block<Eigen::Matrix<double, -1, -1, 0, -1, -1> const, -1, 1, false> const>, Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::DenseShape, Eigen::DenseShape, 5>::sub const&, Eigen::internal::false_type const&)
  814,700,300   28   16   304,618,800  25,619,525  18,746,441    50,599,550         0         0  /usr/lib64/gcc/x86_64-slackware-linux/9.3.0/include/emmintrin.h:Eigen::internal::selfadjoint_matrix_vector_product<double, long, 0, 1, false, false, 0>::run(long, double const*, long, double const*, double*, double)
  714,603,351    9    3   306,258,579  25,903,283  18,938,815   102,086,193         0         0  /usr/lib64/gcc/x86_64-slackware-linux/9.3.0/include/emmintrin.h:Eigen::internal::selfadjoint_rank2_update_selector<double, long, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1, 0, -1, -1>, -1, 1, true>, -1, 1, false>, Eigen::Block<Eigen::Matrix<double, -1, 1, 0, -1, 1>, -1, 1, false>, 1>::run(double*, long, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1, 0, -1, -1>, -1, 1, true>, -1, 1, false> const&, Eigen::Block<Eigen::Matrix<double, -1, 1, 0, -1, 1>, -1, 1, false> const&, double const&)
  625,279,894   35   15       698,015           0           0             0         0         0  /home/renzo/repos/spack/opt/spack/linux-slackware14-core2/gcc-9.3.0/eigen-3.3.7-d3fwbpqkxuuxfzl43t63y74jaxvht3bx/include/eigen3/Eigen/src/Core/AssignEvaluator.h:void Eigen::internal::outer_product_selector_run<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1, 0, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, -1, 1> const> const, Eigen::Block<Eigen::Matrix<double, -1, -1, 0, -1, -1> const, -1, 1, false> const>, Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, -1, 1> const> const, Eigen::Block<Eigen::Matrix<double, -1, -1, 0, -1, -1> const, -1, 1, false> const>, Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::DenseShape, Eigen::DenseShape, 5>::sub>(Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1, 0, -1, -1>, -1, -1, false>, -1, -1, false>&, Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, -1, 1> const> const, Eigen::Block<Eigen::Matrix<double, -1, -1, 0, -1, -1> const, -1, 1, false> const> const&, Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, -1>, 0, Eigen::Stride<0, 0> > const&, Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, -1, 1> const> const, Eigen::Block<Eigen::Matrix<double, -1, -1, 0, -1, -1> const, -1, 1, false> const>, Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::DenseShape, Eigen::DenseShape, 5>::sub const&, Eigen::internal::false_type const&)
  613,042,896   24   12   254,954,106  58,414,614  44,143,629             0         0         0  /usr/lib64/gcc/x86_64-slackware-linux/9.3.0/include/emmintrin.h:Eigen::internal::general_matrix_vector_product<long, double, Eigen::internal::const_blas_data_mapper<double, long, 1>, 1, false, double, Eigen::internal::const_blas_data_mapper<double, long, 0>, false, 0>::run(long, long, Eigen::internal::const_blas_data_mapper<double, long, 1> const&, Eigen::internal::const_blas_data_mapper<double, long, 0> const&, double*, long, double)
  319,163,433    1    1             0           0           0             0         0         0  /home/renzo/repos/spack/opt/spack/linux-slackware14-core2/gcc-9.3.0/eigen-3.3.7-d3fwbpqkxuuxfzl43t63y74jaxvht3bx/include/eigen3/Eigen/src/Core/AssignEvaluator.h:Eigen::internal::selfadjoint_rank2_update_selector<double, long, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1, 0, -1, -1>, -1, 1, true>, -1, 1, false>, Eigen::Block<Eigen::Matrix<double, -1, 1, 0, -1, 1>, -1, 1, false>, 1>::run(double*, long, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1, 0, -1, -1>, -1, 1, true>, -1, 1, false> const&, Eigen::Block<Eigen::Matrix<double, -1, 1, 0, -1, 1>, -1, 1, false> const&, double const&)
  191,961,202  161   80     8,155,181      22,789         914     4,360,498    18,906       273  /home/renzo/repos/spack/opt/spack/linux-slackware14-core2/gcc-9.3.0/eigen-3.3.7-d3fwbpqkxuuxfzl43t63y74jaxvht3bx/include/eigen3/Eigen/src/Core/products/SelfadjointMatrixVector.h:Eigen::internal::selfadjoint_matrix_vector_product<double, long, 0, 1, false, false, 0>::run(long, double const*, long, double const*, double*, double)
  172,771,053  128   64     6,148,713     143,602         470     2,193,252       311       174  /home/renzo/repos/spack/opt/spack/linux-slackware14-core2/gcc-9.3.0/eigen-3.3.7-d3fwbpqkxuuxfzl43t63y74jaxvht3bx/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:Eigen::internal::gebp_kernel<double, double, long, Eigen::internal::blas_data_mapper<double, long, 0, 0>, 4, 4, false, false>::operator()(Eigen::internal::blas_data_mapper<double, long, 0, 0> const&, double const*, double const*, long, long, long, double, long, long, long, long) [clone .constprop.0]
  164,212,235  144   70     2,916,845     359,624      29,935     1,075,870     4,448     2,768  /home/renzo/repos/spack/opt/spack/linux-slackware14-core2/gcc-9.3.0/eigen-3.3.7-d3fwbpqkxuuxfzl43t63y74jaxvht3bx/include/eigen3/Eigen/src/Core/products/GeneralMatrixVector.h:Eigen::internal::general_matrix_vector_product<long, double, Eigen::internal::const_blas_data_mapper<double, long, 1>, 1, false, double, Eigen::internal::const_blas_data_mapper<double, long, 0>, false, 0>::run(long, long, Eigen::internal::const_blas_data_mapper<double, long, 1> const&, Eigen::internal::const_blas_data_mapper<double, long, 0> const&, double*, long, double)
   82,201,119  133   60    14,313,628     292,081     140,601     5,954,268         0         0  /home/renzo/repos/spack/opt/spack/linux-slackware14-core2/gcc-9.3.0/eigen-3.3.7-d3fwbpqkxuuxfzl43t63y74jaxvht3bx/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:Eigen::ComputationInfo Eigen::internal::computeFromTridiagonal_impl<Eigen::Matrix<double, -1, -1, 0, -1, -1>, Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, -1, 1, 0, -1, 1> >(Eigen::Matrix<double, -1, 1, 0, -1, 1>&, Eigen::Matrix<double, -1, 1, 0, -1, 1>&, long, bool, Eigen::Matrix<double, -1, -1, 0, -1, -1>&)
   61,748,928    0    0             0           0           0             0         0         0  /usr/lib64/gcc/x86_64-slackware-linux/9.3.0/include/xmmintrin.h:Eigen::internal::gebp_kernel<double, double, long, Eigen::internal::blas_data_mapper<double, long, 0, 0>, 4, 4, false, false>::operator()(Eigen::internal::blas_data_mapper<double, long, 0, 0> const&, double const*, double const*, long, long, long, double, long, long, long, long) [clone .constprop.0]
   30,928,498   37   16     2,381,106           0           0    13,080,138       235       234  /home/renzo/repos/spack/opt/spack/linux-slackware14-core2/gcc-9.3.0/eigen-3.3.7-d3fwbpqkxuuxfzl43t63y74jaxvht3bx/include/eigen3/Eigen/src/Core/MapBase.h:Eigen::ComputationInfo Eigen::internal::computeFromTridiagonal_impl<Eigen::Matrix<double, -1, -1, 0, -1, -1>, Eigen::Matrix<double, -1, 1, 0, -1, 1>, Eigen::Matrix<double, -1, 1, 0, -1, 1> >(Eigen::Matrix<double, -1, 1, 0, -1, 1>&, Eigen::Matrix<double, -1, 1, 0, -1, 1>&, long, bool, Eigen::Matrix<double, -1, -1, 0, -1, -1>&)
   29,317,134   28   12     9,772,378           0           0     9,772,378         0         0  /home/renzo/repos/spack/opt/spack/linux-slackware14-core2/gcc-9.3.0/eigen-3.3.7-d3fwbpqkxuuxfzl43t63y74jaxvht3bx/include/eigen3/Eigen/src/Core/Block.h:Eigen::internal::selfadjoint_rank2_update_selector<double, long, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1, 0, -1, -1>, -1, 1, true>, -1, 1, false>, Eigen::Block<Eigen::Matrix<double, -1, 1, 0, -1, 1>, -1, 1, false>, 1>::run(double*, long, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1, 0, -1, -1>, -1, 1, true>, -1, 1, false> const&, Eigen::Block<Eigen::Matrix<double, -1, 1, 0, -1, 1>, -1, 1, false> const&, double const&)

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/renzo/repos/spack/opt/spack/linux-slackware14-core2/gcc-9.3.0/eigen-3.3.7-d3fwbpqkxuuxfzl43t63y74jaxvht3bx/include/eigen3/Eigen/src/Core/MapBase.h
--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr        D1mr  DLmr Dw         D1mw   DLmw  

-- line 29 ----------------------------------------
         .    .    .         .     .    .          .      .     .    * See \link TopicCustomizing_Plugins customizing Eigen \endlink for details.
         .    .    .         .     .    .          .      .     .    *
         .    .    .         .     .    .          .      .     .    * The \c Derived class has to provide the following two methods describing the memory layout:
         .    .    .         .     .    .          .      .     .    *  \code Index innerStride() const; \endcode
         .    .    .         .     .    .          .      .     .    *  \code Index outerStride() const; \endcode
         .    .    .         .     .    .          .      .     .    *
         .    .    .         .     .    .          .      .     .    * \sa class Map, class Block
         .    .    .         .     .    .          .      .     .    */
10,645,279  131   56 5,667,593     0    0  4,977,686  3,962 2,433  template<typename Derived> class MapBase<Derived, ReadOnlyAccessors>
         .    .    .         .     .    .          .      .     .    : public internal::dense_xpr_base<Derived>::type
         .    .    .         .     .    .          .      .     .  {
         .    .    .         .     .    .          .      .     .    public:
         .    .    .         .     .    .          .      .     .  
         .    .    .         .     .    .          .      .     .      typedef typename internal::dense_xpr_base<Derived>::type Base;
         .    .    .         .     .    .          .      .     .      enum {
         .    .    .         .     .    .          .      .     .        RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,
         .    .    .         .     .    .          .      .     .        ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,
-- line 45 ----------------------------------------
-- line 82 ----------------------------------------
         .    .    .         .     .    .          .      .     .      using Base::colStride;
         .    .    .         .     .    .          .      .     .  
         .    .    .         .     .    .          .      .     .      // bug 217 - compile error on ICC 11.1
         .    .    .         .     .    .          .      .     .      using Base::operator=;
         .    .    .         .     .    .          .      .     .  
         .    .    .         .     .    .          .      .     .      typedef typename Base::CoeffReturnType CoeffReturnType;
         .    .    .         .     .    .          .      .     .  
         .    .    .         .     .    .          .      .     .      /** \copydoc DenseBase::rows() */
 4,023,318   38   16 4,023,318 1,620  528          0      0     0      EIGEN_DEVICE_FUNC inline Index rows() const { return m_rows.value(); }
         .    .    .         .     .    .          .      .     .      /** \copydoc DenseBase::cols() */
    12,160   28   13    12,160 1,086  797          0      0     0      EIGEN_DEVICE_FUNC inline Index cols() const { return m_cols.value(); }
         .    .    .         .     .    .          .      .     .  
         .    .    .         .     .    .          .      .     .      /** Returns a pointer to the first coefficient of the matrix or vector.
         .    .    .         .     .    .          .      .     .        *
         .    .    .         .     .    .          .      .     .        * \note When addressing this data, make sure to honor the strides returned by innerStride() and outerStride().
         .    .    .         .     .    .          .      .     .        *
         .    .    .         .     .    .          .      .     .        * \sa innerStride(), outerStride()
         .    .    .         .     .    .          .      .     .        */
         .    .    .         .     .    .          .      .     .      EIGEN_DEVICE_FUNC inline const Scalar* data() const { return m_data; }
-- line 100 ----------------------------------------
-- line 156 ----------------------------------------
         .    .    .         .     .    .          .      .     .      /** \internal Constructor for dynamically sized vectors */
         .    .    .         .     .    .          .      .     .      EIGEN_DEVICE_FUNC
         .    .    .         .     .    .          .      .     .      inline MapBase(PointerType dataPtr, Index vecSize)
         .    .    .         .     .    .          .      .     .              : m_data(dataPtr),
         .    .    .         .     .    .          .      .     .                m_rows(RowsAtCompileTime == Dynamic ? vecSize : Index(RowsAtCompileTime)),
         .    .    .         .     .    .          .      .     .                m_cols(ColsAtCompileTime == Dynamic ? vecSize : Index(ColsAtCompileTime))
         .    .    .         .     .    .          .      .     .      {
         .    .    .         .     .    .          .      .     .        EIGEN_STATIC_ASSERT_VECTOR_ONLY(Derived)
     4,050    0    0         0     0    0          0      0     0        eigen_assert(vecSize >= 0);
         .    .    .         .     .    .          .      .     .        eigen_assert(dataPtr == 0 || SizeAtCompileTime == Dynamic || SizeAtCompileTime == vecSize);
         .    .    .         .     .    .          .      .     .        checkSanity<Derived>();
         .    .    .         .     .    .          .      .     .      }
         .    .    .         .     .    .          .      .     .  
         .    .    .         .     .    .          .      .     .      /** \internal Constructor for dynamically sized matrices */
         .    .    .         .     .    .          .      .     .      EIGEN_DEVICE_FUNC
 4,525,964  105   44         0     0    0          0      0     0      inline MapBase(PointerType dataPtr, Index rows, Index cols)
 4,530,025    0    0         0     0    0  4,530,025 15,591 8,442              : m_data(dataPtr), m_rows(rows), m_cols(cols)
         .    .    .         .     .    .          .      .     .      {
11,435,157   10    4         0     0    0          0      0     0        eigen_assert( (dataPtr == 0)
         .    .    .         .     .    .          .      .     .                || (   rows >= 0 && (RowsAtCompileTime == Dynamic || RowsAtCompileTime == rows)
         .    .    .         .     .    .          .      .     .                    && cols >= 0 && (ColsAtCompileTime == Dynamic || ColsAtCompileTime == cols)));
         .    .    .         .     .    .          .      .     .        checkSanity<Derived>();
 9,051,928    0    0 4,525,964     0    0          0      0     0      }
         .    .    .         .     .    .          .      .     .  
         .    .    .         .     .    .          .      .     .      #ifdef EIGEN_MAPBASE_PLUGIN
         .    .    .         .     .    .          .      .     .      #include EIGEN_MAPBASE_PLUGIN
         .    .    .         .     .    .          .      .     .      #endif
         .    .    .         .     .    .          .      .     .  
         .    .    .         .     .    .          .      .     .    protected:
         .    .    .         .     .    .          .      .     .  
         .    .    .         .     .    .          .      .     .      template<typename T>
-- line 186 ----------------------------------------
-- line 257 ----------------------------------------
         .    .    .         .     .    .          .      .     .      {
         .    .    .         .     .    .          .      .     .        return this->m_data[col * colStride() + row * rowStride()];
         .    .    .         .     .    .          .      .     .      }
         .    .    .         .     .    .          .      .     .  
         .    .    .         .     .    .          .      .     .      EIGEN_DEVICE_FUNC
         .    .    .         .     .    .          .      .     .      inline ScalarWithConstIfNotLvalue& coeffRef(Index index)
         .    .    .         .     .    .          .      .     .      {
         .    .    .         .     .    .          .      .     .        EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS(Derived)
     8,144    0    0         0     0    0      4,072      0     0        return this->m_data[index * innerStride()];
         .    .    .         .     .    .          .      .     .      }
         .    .    .         .     .    .          .      .     .  
         .    .    .         .     .    .          .      .     .      template<int StoreMode>
         .    .    .         .     .    .          .      .     .      inline void writePacket(Index row, Index col, const PacketScalar& val)
         .    .    .         .     .    .          .      .     .      {
         .    .    .         .     .    .          .      .     .        internal::pstoret<Scalar, PacketScalar, StoreMode>
         .    .    .         .     .    .          .      .     .                 (this->m_data + (col * colStride() + row * rowStride()), val);
         .    .    .         .     .    .          .      .     .      }
-- line 273 ----------------------------------------
-- line 277 ----------------------------------------
         .    .    .         .     .    .          .      .     .      {
         .    .    .         .     .    .          .      .     .        EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS(Derived)
         .    .    .         .     .    .          .      .     .        internal::pstoret<Scalar, PacketScalar, StoreMode>
         .    .    .         .     .    .          .      .     .                  (this->m_data + index * innerStride(), val);
         .    .    .         .     .    .          .      .     .      }
         .    .    .         .     .    .          .      .     .  
         .    .    .         .     .    .          .      .     .      EIGEN_DEVICE_FUNC explicit inline MapBase(PointerType dataPtr) : Base(dataPtr) {}
         .    .    .         .     .    .          .      .     .      EIGEN_DEVICE_FUNC inline MapBase(PointerType dataPtr, Index vecSize) : Base(dataPtr, vecSize) {}
30,309,642   75   32 1,188,566     0    0 14,527,032    240   237      EIGEN_DEVICE_FUNC inline MapBase(PointerType dataPtr, Index rows, Index cols) : Base(dataPtr, rows, cols) {}
         .    .    .         .     .    .          .      .     .  
         .    .    .         .     .    .          .      .     .      EIGEN_DEVICE_FUNC
         .    .    .         .     .    .          .      .     .      Derived& operator=(const MapBase& other)
         .    .    .         .     .    .          .      .     .      {
         .    .    .         .     .    .          .      .     .        ReadOnlyMapBase::Base::operator=(other);
         .    .    .         .     .    .          .      .     .        return derived();
         .    .    .         .     .    .          .      .     .      }
         .    .    .         .     .    .          .      .     .  
-- line 293 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/renzo/repos/spack/opt/spack/linux-slackware14-core2/gcc-9.3.0/eigen-3.3.7-d3fwbpqkxuuxfzl43t63y74jaxvht3bx/include/eigen3/Eigen/src/Core/products/GeneralMatrixVector.h
--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr      D1mr    DLmr   Dw      D1mw  DLmw  

-- line 356 ----------------------------------------
          .    .    .       .       .      .       .     .     .    Index rows, Index cols,
          .    .    .       .       .      .       .     .     .    const LhsMapper& lhs,
          .    .    .       .       .      .       .     .     .    const RhsMapper& rhs,
          .    .    .       .       .      .       .     .     .          ResScalar* res, Index resIncr,
          .    .    .       .       .      .       .     .     .    ResScalar alpha);
          .    .    .       .       .      .       .     .     .  };
          .    .    .       .       .      .       .     .     .  
          .    .    .       .       .      .       .     .     .  template<typename Index, typename LhsScalar, typename LhsMapper, bool ConjugateLhs, typename RhsScalar, typename RhsMapper, bool ConjugateRhs, int Version>
     30,375    9    4   2,025       0      0  20,250 1,639 1,106  EIGEN_DONT_INLINE void general_matrix_vector_product<Index,LhsScalar,LhsMapper,RowMajor,ConjugateLhs,RhsScalar,RhsMapper,ConjugateRhs,Version>::run(
          .    .    .       .       .      .       .     .     .    Index rows, Index cols,
          .    .    .       .       .      .       .     .     .    const LhsMapper& lhs,
          .    .    .       .       .      .       .     .     .    const RhsMapper& rhs,
          .    .    .       .       .      .       .     .     .    ResScalar* res, Index resIncr,
          .    .    .       .       .      .       .     .     .    ResScalar alpha)
          .    .    .       .       .      .       .     .     .  {
          .    .    .       .       .      .       .     .     .    eigen_internal_assert(rhs.stride()==1);
          .    .    .       .       .      .       .     .     .  
-- line 372 ----------------------------------------
-- line 387 ----------------------------------------
          .    .    .       .       .      .       .     .     .    typedef typename LhsMapper::VectorMapper LhsScalars;
          .    .    .       .       .      .       .     .     .  
          .    .    .       .       .      .       .     .     .    enum { AllAligned=0, EvenAligned=1, FirstAligned=2, NoneAligned=3 };
          .    .    .       .       .      .       .     .     .    const Index rowsAtOnce = 4;
          .    .    .       .       .      .       .     .     .    const Index peels = 2;
          .    .    .       .       .      .       .     .     .    const Index RhsPacketAlignedMask = RhsPacketSize-1;
          .    .    .       .       .      .       .     .     .    const Index LhsPacketAlignedMask = LhsPacketSize-1;
          .    .    .       .       .      .       .     .     .    const Index depth = cols;
      8,100    0    0   2,025       0      0   4,050 1,392   831    const Index lhsStride = lhs.stride();
          .    .    .       .       .      .       .     .     .  
          .    .    .       .       .      .       .     .     .    // How many coeffs of the result do we have to skip to be aligned.
          .    .    .       .       .      .       .     .     .    // Here we assume data are at least aligned on the base scalar type
          .    .    .       .       .      .       .     .     .    // if that's not the case then vectorization is discarded, see below.
      2,025    9    4   2,025       0      0       0     0     0    Index alignedStart = rhs.firstAligned(depth);
     10,125    9    4       0       0      0       0     0     0    Index alignedSize = RhsPacketSize>1 ? alignedStart + ((depth-alignedStart) & ~RhsPacketAlignedMask) : 0;
      4,050    0    0       0       0      0   2,025 1,417   831    const Index peeledSize = alignedSize - RhsPacketSize*peels - RhsPacketSize + 1;
          .    .    .       .       .      .       .     .     .  
          .    .    .       .       .      .       .     .     .    const Index alignmentStep = LhsPacketSize>1 ? (LhsPacketSize - lhsStride % LhsPacketSize) & LhsPacketAlignedMask : 0;
          .    .    .       .       .      .       .     .     .    Index alignmentPattern = alignmentStep==0 ? AllAligned
          .    .    .       .       .      .       .     .     .                             : alignmentStep==(LhsPacketSize/2) ? EvenAligned
          .    .    .       .       .      .       .     .     .                             : FirstAligned;
          .    .    .       .       .      .       .     .     .  
          .    .    .       .       .      .       .     .     .    // we cannot assume the first element is aligned because of sub-matrices
          .    .    .       .       .      .       .     .     .    const Index lhsAlignmentOffset = lhs.firstAligned(depth);
          .    .    .       .       .      .       .     .     .    const Index rhsAlignmentOffset = rhs.firstAligned(rows);
          .    .    .       .       .      .       .     .     .  
          .    .    .       .       .      .       .     .     .    // find how many rows do we have to skip to be aligned with rhs (if possible)
          8    8    3       0       0      0       8     0     0    Index skipRows = 0;
          .    .    .       .       .      .       .     .     .    // if the data cannot be aligned (TODO add some compile time tests when possible, e.g. for floats)
      4,050    0    0       0       0      0       0     0     0    if( (sizeof(LhsScalar)!=sizeof(RhsScalar)) ||
          .    .    .       .       .      .       .     .     .        (lhsAlignmentOffset < 0) || (lhsAlignmentOffset == depth) ||
      8,068    0    0   2,017       0      0       0     0     0        (rhsAlignmentOffset < 0) || (rhsAlignmentOffset == rows) )
          .    .    .       .       .      .       .     .     .    {
          8    0    0       0       0      0       0     0     0      alignedSize = 0;
          8    0    0       0       0      0       0     0     0      alignedStart = 0;
          8    0    0       0       0      0       8     0     0      alignmentPattern = NoneAligned;
          .    .    .       .       .      .       .     .     .    }
          .    .    .       .       .      .       .     .     .    else if(LhsPacketSize > 4)
          .    .    .       .       .      .       .     .     .    {
          .    .    .       .       .      .       .     .     .      // TODO: extend the code to support aligned loads whenever possible when LhsPacketSize > 4.
          .    .    .       .       .      .       .     .     .      alignmentPattern = NoneAligned;
          .    .    .       .       .      .       .     .     .    }
          .    .    .       .       .      .       .     .     .    else if (LhsPacketSize>1)
          .    .    .       .       .      .       .     .     .    {
          .    .    .       .       .      .       .     .     .    //    eigen_internal_assert(size_t(firstLhs+lhsAlignmentOffset)%sizeof(LhsPacket)==0  || depth<LhsPacketSize);
          .    .    .       .       .      .       .     .     .  
     22,187   19    9   2,017       0      0   2,017     0     0      while (skipRows<LhsPacketSize &&
     16,136    0    0   2,017       0      0   2,017     0     0             alignedStart != ((lhsAlignmentOffset + alignmentStep*skipRows)%LhsPacketSize))
          .    .    .       .       .      .       .     .     .        ++skipRows;
          .    .    .       .       .      .       .     .     .      if (skipRows==LhsPacketSize)
          .    .    .       .       .      .       .     .     .      {
          .    .    .       .       .      .       .     .     .        // nothing can be aligned, no need to skip any column
          .    .    .       .       .      .       .     .     .        alignmentPattern = NoneAligned;
          .    .    .       .       .      .       .     .     .        skipRows = 0;
          .    .    .       .       .      .       .     .     .      }
          .    .    .       .       .      .       .     .     .      else
-- line 442 ----------------------------------------
-- line 455 ----------------------------------------
          .    .    .       .       .      .       .     .     .      alignedStart = 0;
          .    .    .       .       .      .       .     .     .      alignedSize = depth;
          .    .    .       .       .      .       .     .     .      alignmentPattern = AllAligned;
          .    .    .       .       .      .       .     .     .    }
          .    .    .       .       .      .       .     .     .  
          .    .    .       .       .      .       .     .     .    const Index offset1 = (alignmentPattern==FirstAligned && alignmentStep==1)?3:1;
          .    .    .       .       .      .       .     .     .    const Index offset3 = (alignmentPattern==FirstAligned && alignmentStep==1)?1:3;
          .    .    .       .       .      .       .     .     .  
     12,150    1    1   2,025       0      0       0     0     0    Index rowBound = ((rows-skipRows)/rowsAtOnce)*rowsAtOnce + skipRows;
  1,050,506    0    0 525,236       0      0 173,740     0     0    for (Index i=skipRows; i<rowBound; i+=rowsAtOnce)
          .    .    .       .       .      .       .     .     .    {
          .    .    .       .       .      .       .     .     .      // FIXME: what is the purpose of this EIGEN_ALIGN_DEFAULT ??
     86,870    0    0       0       0      0       0     0     0      EIGEN_ALIGN_MAX ResScalar tmp0 = ResScalar(0);
    260,610    0    0       0       0      0       0     0     0      ResScalar tmp1 = ResScalar(0), tmp2 = ResScalar(0), tmp3 = ResScalar(0);
          .    .    .       .       .      .       .     .     .  
          .    .    .       .       .      .       .     .     .      // this helps the compiler generating good binary code
          .    .    .       .       .      .       .     .     .      const LhsScalars lhs0 = lhs.getVectorMapper(i+0, 0),    lhs1 = lhs.getVectorMapper(i+offset1, 0),
          .    .    .       .       .      .       .     .     .                       lhs2 = lhs.getVectorMapper(i+2, 0),    lhs3 = lhs.getVectorMapper(i+offset3, 0);
          .    .    .       .       .      .       .     .     .  
          .    .    .       .       .      .       .     .     .      if (Vectorizable)
          .    .    .       .       .      .       .     .     .      {
          .    .    .       .       .      .       .     .     .        /* explicit vectorization */
          .    .    .       .       .      .       .     .     .        ResPacket ptmp0 = pset1<ResPacket>(ResScalar(0)), ptmp1 = pset1<ResPacket>(ResScalar(0)),
          .    .    .       .       .      .       .     .     .                  ptmp2 = pset1<ResPacket>(ResScalar(0)), ptmp3 = pset1<ResPacket>(ResScalar(0));
          .    .    .       .       .      .       .     .     .  
          .    .    .       .       .      .       .     .     .        // process initial unaligned coeffs
          .    .    .       .       .      .       .     .     .        // FIXME this loop get vectorized by the compiler !
    434,350    0    0 173,740       0      0       0     0     0        for (Index j=0; j<alignedStart; ++j)
          .    .    .       .       .      .       .     .     .        {
     86,870    8    4  86,870  49,963    394       0     0     0          RhsScalar b = rhs(j, 0);
    173,740    0    0       0       0      0       0     0     0          tmp0 += cj.pmul(lhs0(j),b); tmp1 += cj.pmul(lhs1(j),b);
    173,740    0    0       0       0      0       0     0     0          tmp2 += cj.pmul(lhs2(j),b); tmp3 += cj.pmul(lhs3(j),b);
          .    .    .       .       .      .       .     .     .        }
          .    .    .       .       .      .       .     .     .  
    347,480    7    4 173,740       0      0       0     0     0        if (alignedSize>alignedStart)
          .    .    .       .       .      .       .     .     .        {
  2,084,880    8    4 347,480  69,585      0       0     0     0          switch(alignmentPattern)
          .    .    .       .       .      .       .     .     .          {
          .    .    .       .       .      .       .     .     .            case AllAligned:
152,518,900    0    0       0       0      0       0     0     0              for (Index j = alignedStart; j<alignedSize; j+=RhsPacketSize)
          .    .    .       .       .      .       .     .     .                _EIGEN_ACCUMULATE_PACKETS(Aligned,Aligned,Aligned);
          .    .    .       .       .      .       .     .     .              break;
          .    .    .       .       .      .       .     .     .            case EvenAligned:
          .    .    .       .       .      .       .     .     .              for (Index j = alignedStart; j<alignedSize; j+=RhsPacketSize)
          .    .    .       .       .      .       .     .     .                _EIGEN_ACCUMULATE_PACKETS(Aligned,Unaligned,Aligned);
          .    .    .       .       .      .       .     .     .              break;
          .    .    .       .       .      .       .     .     .            case FirstAligned:
          .    .    .       .       .      .       .     .     .            {
-- line 502 ----------------------------------------
-- line 540 ----------------------------------------
          .    .    .       .       .      .       .     .     .                _EIGEN_ACCUMULATE_PACKETS(Aligned,Unaligned,Unaligned);
          .    .    .       .       .      .       .     .     .              break;
          .    .    .       .       .      .       .     .     .            }
          .    .    .       .       .      .       .     .     .            default:
          .    .    .       .       .      .       .     .     .              for (Index j = alignedStart; j<alignedSize; j+=RhsPacketSize)
          .    .    .       .       .      .       .     .     .                _EIGEN_ACCUMULATE_PACKETS(Unaligned,Unaligned,Unaligned);
          .    .    .       .       .      .       .     .     .              break;
          .    .    .       .       .      .       .     .     .          }
    173,740    0    0       0       0      0       0     0     0          tmp0 += predux(ptmp0);
    173,740    0    0       0       0      0       0     0     0          tmp1 += predux(ptmp1);
    173,740    0    0       0       0      0       0     0     0          tmp2 += predux(ptmp2);
    173,740    0    0       0       0      0       0     0     0          tmp3 += predux(ptmp3);
          .    .    .       .       .      .       .     .     .        }
          .    .    .       .       .      .       .     .     .      } // end explicit vectorization
          .    .    .       .       .      .       .     .     .  
          .    .    .       .       .      .       .     .     .      // process remaining coeffs (or all if no explicit vectorization)
          .    .    .       .       .      .       .     .     .      // FIXME this loop get vectorized by the compiler !
    347,480    0    0 173,740  66,657      0       0     0     0      for (Index j=alignedSize; j<depth; ++j)
          .    .    .       .       .      .       .     .     .      {
          .    .    .       .       .      .       .     .     .        RhsScalar b = rhs(j, 0);
          .    .    .       .       .      .       .     .     .        tmp0 += cj.pmul(lhs0(j),b); tmp1 += cj.pmul(lhs1(j),b);
          .    .    .       .       .      .       .     .     .        tmp2 += cj.pmul(lhs2(j),b); tmp3 += cj.pmul(lhs3(j),b);
          .    .    .       .       .      .       .     .     .      }
    694,960   16    8 347,480 101,258 27,695 173,740     0     0      res[i*resIncr]            += alpha*tmp0;
  1,737,400    0    0 521,220  68,256      0 347,480     0     0      res[(i+offset1)*resIncr]  += alpha*tmp1;
    868,700    0    0 173,740     544      0 173,740     0     0      res[(i+2)*resIncr]        += alpha*tmp2;
    868,700    0    0 347,480       0      0 173,740     0     0      res[(i+offset3)*resIncr]  += alpha*tmp3;
          .    .    .       .       .      .       .     .     .    }
          .    .    .       .       .      .       .     .     .  
          .    .    .       .       .      .       .     .     .    // process remaining first and last rows (at most columnsAtOnce-1)
          .    .    .       .       .      .       .     .     .    Index end = rows;
          .    .    .       .       .      .       .     .     .    Index start = rowBound;
          .    .    .       .       .      .       .     .     .    do
          .    .    .       .       .      .       .     .     .    {
     26,421   27   12  11,683       0      0       0     0     0      for (Index i=start; i<end; ++i)
          .    .    .       .       .      .       .     .     .      {
      3,055    0    0       0       0      0       0     0     0        EIGEN_ALIGN_MAX ResScalar tmp0 = ResScalar(0);
      3,039    0    0       0       0      0       0     0     0        ResPacket ptmp0 = pset1<ResPacket>(tmp0);
          .    .    .       .       .      .       .     .     .        const LhsScalars lhs0 = lhs.getVectorMapper(i, 0);
          .    .    .       .       .      .       .     .     .        // process first unaligned result's coeffs
          .    .    .       .       .      .       .     .     .        // FIXME this loop get vectorized by the compiler !
      6,110    0    0       0       0      0       0     0     0        for (Index j=0; j<alignedStart; ++j)
      2,008    0    0       0       0      0       0     0     0          tmp0 += cj.pmul(lhs0(j), rhs(j, 0));
          .    .    .       .       .      .       .     .     .  
      6,110    0    0       0       0      0       0     0     0        if (alignedSize>alignedStart)
          .    .    .       .       .      .       .     .     .        {
          .    .    .       .       .      .       .     .     .          // process aligned rhs coeffs
     12,156    1    1       0       0      0       0     0     0          if (lhs0.template aligned<LhsPacket>(alignedStart))
  1,568,259    0    0       0       0      0       0     0     0            for (Index j = alignedStart;j<alignedSize;j+=RhsPacketSize)
          .    .    .       .       .      .       .     .     .              ptmp0 = pcj.pmadd(lhs0.template load<LhsPacket, Aligned>(j), rhs.getVectorMapper(j, 0).template load<RhsPacket, Aligned>(0), ptmp0);
          .    .    .       .       .      .       .     .     .          else
          .    .    .       .       .      .       .     .     .            for (Index j = alignedStart;j<alignedSize;j+=RhsPacketSize)
          .    .    .       .       .      .       .     .     .              ptmp0 = pcj.pmadd(lhs0.template load<LhsPacket, Unaligned>(j), rhs.getVectorMapper(j, 0).template load<RhsPacket, Aligned>(0), ptmp0);
      3,039    0    0       0       0      0       0     0     0          tmp0 += predux(ptmp0);
          .    .    .       .       .      .       .     .     .        }
          .    .    .       .       .      .       .     .     .  
          .    .    .       .       .      .       .     .     .        // process remaining scalars
          .    .    .       .       .      .       .     .     .        // FIXME this loop get vectorized by the compiler !
      6,142   13    7   3,055       0      0       0     0     0        for (Index j=alignedSize; j<depth; ++j)
         32    0    0       0       0      0       0     0     0          tmp0 += cj.pmul(lhs0(j), rhs(j, 0));
     12,220    1    1   3,055     453    186   3,055     0     0        res[i*resIncr] += alpha*tmp0;
          .    .    .       .       .      .       .     .     .      }
          .    .    .       .       .      .       .     .     .      if (skipRows)
          .    .    .       .       .      .       .     .     .      {
          .    .    .       .       .      .       .     .     .        start = 0;
          .    .    .       .       .      .       .     .     .        end = skipRows;
          .    .    .       .       .      .       .     .     .        skipRows = 0;
          .    .    .       .       .      .       .     .     .      }
          .    .    .       .       .      .       .     .     .      else
          .    .    .       .       .      .       .     .     .        break;
          .    .    .       .       .      .       .     .     .    } while(Vectorizable);
          .    .    .       .       .      .       .     .     .  
          .    .    .       .       .      .       .     .     .    #undef _EIGEN_ACCUMULATE_PACKETS
     16,200    8    4  14,175   2,908  1,660       0     0     0  }
          .    .    .       .       .      .       .     .     .  
          .    .    .       .       .      .       .     .     .  } // end namespace internal
          .    .    .       .       .      .       .     .     .  
          .    .    .       .       .      .       .     .     .  } // end namespace Eigen
          .    .    .       .       .      .       .     .     .  
          .    .    .       .       .      .       .     .     .  #endif // EIGEN_GENERAL_MATRIX_VECTOR_H

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/renzo/repos/spack/opt/spack/linux-slackware14-core2/gcc-9.3.0/eigen-3.3.7-d3fwbpqkxuuxfzl43t63y74jaxvht3bx/include/eigen3/Eigen/src/Jacobi/Jacobi.h
--------------------------------------------------------------------------------
Ir            I1mr ILmr Dr          D1mr        DLmr        Dw          D1mw DLmw 

-- line 51 ----------------------------------------
            .    .    .           .           .           .           .    .    .      JacobiRotation operator*(const JacobiRotation& other)
            .    .    .           .           .           .           .    .    .      {
            .    .    .           .           .           .           .    .    .        using numext::conj;
            .    .    .           .           .           .           .    .    .        return JacobiRotation(m_c * other.m_c - conj(m_s) * other.m_s,
            .    .    .           .           .           .           .    .    .                              conj(m_c * conj(other.m_s) + conj(m_s) * conj(other.m_c)));
            .    .    .           .           .           .           .    .    .      }
            .    .    .           .           .           .           .    .    .  
            .    .    .           .           .           .           .    .    .      /** Returns the transposed transformation */
   13,074,226    9    4   1,188,566           0           0           0    0    0      JacobiRotation transpose() const { using numext::conj; return JacobiRotation(m_c, -conj(m_s)); }
            .    .    .           .           .           .           .    .    .  
            .    .    .           .           .           .           .    .    .      /** Returns the adjoint transformation */
            .    .    .           .           .           .           .    .    .      JacobiRotation adjoint() const { using numext::conj; return JacobiRotation(conj(m_c), -m_s); }
            .    .    .           .           .           .           .    .    .  
            .    .    .           .           .           .           .    .    .      template<typename Derived>
            .    .    .           .           .           .           .    .    .      bool makeJacobi(const MatrixBase<Derived>&, Index p, Index q);
            .    .    .           .           .           .           .    .    .      bool makeJacobi(const RealScalar& x, const Scalar& y, const RealScalar& z);
            .    .    .           .           .           .           .    .    .  
-- line 67 ----------------------------------------
-- line 211 ----------------------------------------
            .    .    .           .           .           .           .    .    .  }
            .    .    .           .           .           .           .    .    .  
            .    .    .           .           .           .           .    .    .  // specialization for reals
            .    .    .           .           .           .           .    .    .  template<typename Scalar>
            .    .    .           .           .           .           .    .    .  void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::false_type)
            .    .    .           .           .           .           .    .    .  {
            .    .    .           .           .           .           .    .    .    using std::sqrt;
            .    .    .           .           .           .           .    .    .    using std::abs;
    3,565,698    0    0           0           0           0           0    0    0    if(q==Scalar(0))
            .    .    .           .           .           .           .    .    .    {
            .    .    .           .           .           .           .    .    .      m_c = p<Scalar(0) ? Scalar(-1) : Scalar(1);
            .    .    .           .           .           .           .    .    .      m_s = Scalar(0);
            .    .    .           .           .           .           .    .    .      if(r) *r = abs(p);
            .    .    .           .           .           .           .    .    .    }
    3,565,698    9    4           0           0           0           0    0    0    else if(p==Scalar(0))
            .    .    .           .           .           .           .    .    .    {
            .    .    .           .           .           .           .    .    .      m_c = Scalar(0);
            .    .    .           .           .           .           .    .    .      m_s = q<Scalar(0) ? Scalar(1) : Scalar(-1);
            .    .    .           .           .           .           .    .    .      if(r) *r = abs(q);
            .    .    .           .           .           .           .    .    .    }
    2,377,132    0    0           0           0           0           0    0    0    else if(abs(p) > abs(q))
            .    .    .           .           .           .           .    .    .    {
    2,048,356    0    0           0           0           0           0    0    0      Scalar t = q/p;
    6,145,068    0    0   1,024,178           0           0           0    0    0      Scalar u = sqrt(Scalar(1) + numext::abs2(t));
    2,048,356    0    0           0           0           0           0    0    0      if(p<Scalar(0))
    1,070,696    0    0   1,024,178         166         165           0    0    0        u = -u;
    3,072,534    8    4           0           0           0           0    0    0      m_c = Scalar(1)/u;
    2,048,356    0    0           0           0           0           0    0    0      m_s = -t * m_c;
            .    .    .           .           .           .           .    .    .      if(r) *r = p * u;
            .    .    .           .           .           .           .    .    .    }
            .    .    .           .           .           .           .    .    .    else
            .    .    .           .           .           .           .    .    .    {
      164,388    1    0           0           0           0           0    0    0      Scalar t = p/q;
      821,940    0    0     164,388           0           0           0    0    0      Scalar u = sqrt(Scalar(1) + numext::abs2(t));
      328,776    0    0           0           0           0           0    0    0      if(q<Scalar(0))
      165,297    8    4     164,388           1           1           0    0    0        u = -u;
      328,776    0    0     164,388           0           0           0    0    0      m_s = -Scalar(1)/u;
      657,552    0    0           0           0           0           0    0    0      m_c = -t * m_s;
            .    .    .           .           .           .           .    .    .      if(r) *r = q * u;
            .    .    .           .           .           .           .    .    .    }
            .    .    .           .           .           .           .    .    .  
            .    .    .           .           .           .           .    .    .  }
            .    .    .           .           .           .           .    .    .  
            .    .    .           .           .           .           .    .    .  /****************************************************************************************
            .    .    .           .           .           .           .    .    .  *   Implementation of MatrixBase methods
            .    .    .           .           .           .           .    .    .  ****************************************************************************************/
-- line 256 ----------------------------------------
-- line 299 ----------------------------------------
            .    .    .           .           .           .           .    .    .  namespace internal {
            .    .    .           .           .           .           .    .    .  
            .    .    .           .           .           .           .    .    .  template<typename Scalar, typename OtherScalar,
            .    .    .           .           .           .           .    .    .           int SizeAtCompileTime, int MinAlignment, bool Vectorizable>
            .    .    .           .           .           .           .    .    .  struct apply_rotation_in_the_plane_selector
            .    .    .           .           .           .           .    .    .  {
            .    .    .           .           .           .           .    .    .    static inline void run(Scalar *x, Index incrx, Scalar *y, Index incry, Index size, OtherScalar c, OtherScalar s)
            .    .    .           .           .           .           .    .    .    {
1,564,451,142    0    0           0           0           0           0    0    0      for(Index i=0; i<size; ++i)
            .    .    .           .           .           .           .    .    .      {
  517,918,016    0    0 517,918,016     255,631     164,449           0    0    0        Scalar xi = *x;
  517,918,016    0    0 517,918,016 129,431,116 107,210,552           0    0    0        Scalar yi = *y;
3,625,426,112    9    4           0           0           0 517,918,016    0    0        *x =  c * xi + numext::conj(s) * yi;
2,071,672,064    0    0           0           0           0 517,918,016    0    0        *y = -s * xi + numext::conj(c) * yi;
            .    .    .           .           .           .           .    .    .        x += incrx;
            .    .    .           .           .           .           .    .    .        y += incry;
            .    .    .           .           .           .           .    .    .      }
            .    .    .           .           .           .           .    .    .    }
            .    .    .           .           .           .           .    .    .  };
            .    .    .           .           .           .           .    .    .  
            .    .    .           .           .           .           .    .    .  template<typename Scalar, typename OtherScalar,
            .    .    .           .           .           .           .    .    .           int SizeAtCompileTime, int MinAlignment>
-- line 320 ----------------------------------------
-- line 430 ----------------------------------------
            .    .    .           .           .           .           .    .    .  
            .    .    .           .           .           .           .    .    .  template<typename VectorX, typename VectorY, typename OtherScalar>
            .    .    .           .           .           .           .    .    .  void /*EIGEN_DONT_INLINE*/ apply_rotation_in_the_plane(DenseBase<VectorX>& xpr_x, DenseBase<VectorY>& xpr_y, const JacobiRotation<OtherScalar>& j)
            .    .    .           .           .           .           .    .    .  {
            .    .    .           .           .           .           .    .    .    typedef typename VectorX::Scalar Scalar;
            .    .    .           .           .           .           .    .    .    const bool Vectorizable =    (VectorX::Flags & VectorY::Flags & PacketAccessBit)
            .    .    .           .           .           .           .    .    .                              && (int(packet_traits<Scalar>::size) == int(packet_traits<OtherScalar>::size));
            .    .    .           .           .           .           .    .    .  
    9,508,528    0    0   7,131,396           0           0           0    0    0    eigen_assert(xpr_x.size() == xpr_y.size());
            .    .    .           .           .           .           .    .    .    Index size = xpr_x.size();
            .    .    .           .           .           .           .    .    .    Index incrx = xpr_x.derived().innerStride();
            .    .    .           .           .           .           .    .    .    Index incry = xpr_y.derived().innerStride();
            .    .    .           .           .           .           .    .    .  
    1,188,566    0    0   1,188,566           0           0           0    0    0    Scalar* EIGEN_RESTRICT x = &xpr_x.derived().coeffRef(0);
   10,697,094    9    4   1,188,566           0           0           0    0    0    Scalar* EIGEN_RESTRICT y = &xpr_y.derived().coeffRef(0);
            .    .    .           .           .           .           .    .    .    
            .    .    .           .           .           .           .    .    .    OtherScalar c = j.c();
            .    .    .           .           .           .           .    .    .    OtherScalar s = j.s();
    8,342,957    9    4   1,188,566           0           0           0    0    0    if (c==OtherScalar(1) && s==OtherScalar(0))
            .    .    .           .           .           .           .    .    .      return;
            .    .    .           .           .           .           .    .    .  
            .    .    .           .           .           .           .    .    .    apply_rotation_in_the_plane_selector<
            .    .    .           .           .           .           .    .    .      Scalar,OtherScalar,
            .    .    .           .           .           .           .    .    .      VectorX::SizeAtCompileTime,
            .    .    .           .           .           .           .    .    .      EIGEN_PLAIN_ENUM_MIN(evaluator<VectorX>::Alignment, evaluator<VectorY>::Alignment),
            .    .    .           .           .           .           .    .    .      Vectorizable>::run(x,incrx,y,incry,size,c,s);
            .    .    .           .           .           .           .    .    .  }
-- line 456 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/renzo/repos/spack/opt/spack/linux-slackware14-core2/gcc-9.3.0/eigen-3.3.7-d3fwbpqkxuuxfzl43t63y74jaxvht3bx/include/eigen3/Eigen/src/Core/Block.h
--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr        D1mr  DLmr Dw        D1mw  DLmw  

-- line 112 ----------------------------------------
         .    .    .         .     .    .         .     .     .      
         .    .    .         .     .    .         .     .     .      typedef typename internal::remove_all<XprType>::type NestedExpression;
         .    .    .         .     .    .         .     .     .    
         .    .    .         .     .    .         .     .     .      /** Column or Row constructor
         .    .    .         .     .    .         .     .     .        */
         .    .    .         .     .    .         .     .     .      EIGEN_DEVICE_FUNC
         .    .    .         .     .    .         .     .     .      inline Block(XprType& xpr, Index i) : Impl(xpr,i)
         .    .    .         .     .    .         .     .     .      {
16,403,260    9    4 6,176,543 2,737  164         0     0     0        eigen_assert( (i>=0) && (
         .    .    .         .     .    .         .     .     .            ((BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) && i<xpr.rows())
         .    .    .         .     .    .         .     .     .          ||((BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) && i<xpr.cols())));
         .    .    .         .     .    .         .     .     .      }
         .    .    .         .     .    .         .     .     .  
         .    .    .         .     .    .         .     .     .      /** Fixed-size constructor
         .    .    .         .     .    .         .     .     .        */
         .    .    .         .     .    .         .     .     .      EIGEN_DEVICE_FUNC
         .    .    .         .     .    .         .     .     .      inline Block(XprType& xpr, Index startRow, Index startCol)
-- line 128 ----------------------------------------
-- line 138 ----------------------------------------
         .    .    .         .     .    .         .     .     .      EIGEN_DEVICE_FUNC
         .    .    .         .     .    .         .     .     .      inline Block(XprType& xpr,
         .    .    .         .     .    .         .     .     .            Index startRow, Index startCol,
         .    .    .         .     .    .         .     .     .            Index blockRows, Index blockCols)
         .    .    .         .     .    .         .     .     .        : Impl(xpr, startRow, startCol, blockRows, blockCols)
         .    .    .         .     .    .         .     .     .      {
         .    .    .         .     .    .         .     .     .        eigen_assert((RowsAtCompileTime==Dynamic || RowsAtCompileTime==blockRows)
         .    .    .         .     .    .         .     .     .            && (ColsAtCompileTime==Dynamic || ColsAtCompileTime==blockCols));
 7,163,570   48   20 2,810,442     4    1         0     0     0        eigen_assert(startRow >= 0 && blockRows >= 0 && startRow  <= xpr.rows() - blockRows
         .    .    .         .     .    .         .     .     .            && startCol >= 0 && blockCols >= 0 && startCol <= xpr.cols() - blockCols);
         .    .    .         .     .    .         .     .     .      }
         .    .    .         .     .    .         .     .     .  };
         .    .    .         .     .    .         .     .     .           
         .    .    .         .     .    .         .     .     .  // The generic default implementation for dense block simplu forward to the internal::BlockImpl_dense
         .    .    .         .     .    .         .     .     .  // that must be specialized for direct and non-direct access...
         .    .    .         .     .    .         .     .     .  template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel>
         .    .    .         .     .    .         .     .     .  class BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, Dense>
-- line 154 ----------------------------------------
-- line 321 ----------------------------------------
         .    .    .         .     .    .         .     .     .      const internal::variable_if_dynamic<StorageIndex, (XprType::RowsAtCompileTime == 1 && BlockRows==1) ? 0 : Dynamic> m_startRow;
         .    .    .         .     .    .         .     .     .      const internal::variable_if_dynamic<StorageIndex, (XprType::ColsAtCompileTime == 1 && BlockCols==1) ? 0 : Dynamic> m_startCol;
         .    .    .         .     .    .         .     .     .      const internal::variable_if_dynamic<StorageIndex, RowsAtCompileTime> m_blockRows;
         .    .    .         .     .    .         .     .     .      const internal::variable_if_dynamic<StorageIndex, ColsAtCompileTime> m_blockCols;
         .    .    .         .     .    .         .     .     .  };
         .    .    .         .     .    .         .     .     .  
         .    .    .         .     .    .         .     .     .  /** \internal Internal implementation of dense Blocks in the direct access case.*/
         .    .    .         .     .    .         .     .     .  template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel>
12,820,772  128   56 6,392,095 1,077  799 6,428,677 6,615 3,213  class BlockImpl_dense<XprType,BlockRows,BlockCols, InnerPanel,true>
         .    .    .         .     .    .         .     .     .    : public MapBase<Block<XprType, BlockRows, BlockCols, InnerPanel> >
         .    .    .         .     .    .         .     .     .  {
         .    .    .         .     .    .         .     .     .      typedef Block<XprType, BlockRows, BlockCols, InnerPanel> BlockType;
         .    .    .         .     .    .         .     .     .      typedef typename internal::ref_selector<XprType>::non_const_type XprTypeNested;
         .    .    .         .     .    .         .     .     .      enum {
         .    .    .         .     .    .         .     .     .        XprTypeIsRowMajor = (int(traits<XprType>::Flags)&RowMajorBit) != 0
         .    .    .         .     .    .         .     .     .      };
         .    .    .         .     .    .         .     .     .    public:
-- line 337 ----------------------------------------
-- line 339 ----------------------------------------
         .    .    .         .     .    .         .     .     .      typedef MapBase<BlockType> Base;
         .    .    .         .     .    .         .     .     .      EIGEN_DENSE_PUBLIC_INTERFACE(BlockType)
         .    .    .         .     .    .         .     .     .      EIGEN_INHERIT_ASSIGNMENT_OPERATORS(BlockImpl_dense)
         .    .    .         .     .    .         .     .     .  
         .    .    .         .     .    .         .     .     .      /** Column or Row constructor
         .    .    .         .     .    .         .     .     .        */
         .    .    .         .     .    .         .     .     .      EIGEN_DEVICE_FUNC
         .    .    .         .     .    .         .     .     .      inline BlockImpl_dense(XprType& xpr, Index i)
 1,444,304   29   12   702,065 1,178  788     3,876     0     0        : Base(xpr.data() + i * (    ((BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) && (!XprTypeIsRowMajor)) 
         .    .    .         .     .    .         .     .     .                                  || ((BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) && ( XprTypeIsRowMajor)) ? xpr.innerStride() : xpr.outerStride()),
         .    .    .         .     .    .         .     .     .               BlockRows==1 ? 1 : xpr.rows(),
         .    .    .         .     .    .         .     .     .               BlockCols==1 ? 1 : xpr.cols()),
         .    .    .         .     .    .         .     .     .          m_xpr(xpr),
         .    .    .         .     .    .         .     .     .          m_startRow( (BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) ? i : 0),
11,263,100   35   16 5,622,432     0    0 4,922,479 5,433 3,244          m_startCol( (BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) ? i : 0)
         .    .    .         .     .    .         .     .     .      {
         .    .    .         .     .    .         .     .     .        init();
         .    .    .         .     .    .         .     .     .      }
         .    .    .         .     .    .         .     .     .  
         .    .    .         .     .    .         .     .     .      /** Fixed-size constructor
         .    .    .         .     .    .         .     .     .        */
         .    .    .         .     .    .         .     .     .      EIGEN_DEVICE_FUNC
         .    .    .         .     .    .         .     .     .      inline BlockImpl_dense(XprType& xpr, Index startRow, Index startCol)
-- line 361 ----------------------------------------
-- line 366 ----------------------------------------
         .    .    .         .     .    .         .     .     .      }
         .    .    .         .     .    .         .     .     .  
         .    .    .         .     .    .         .     .     .      /** Dynamic-size constructor
         .    .    .         .     .    .         .     .     .        */
         .    .    .         .     .    .         .     .     .      EIGEN_DEVICE_FUNC
         .    .    .         .     .    .         .     .     .      inline BlockImpl_dense(XprType& xpr,
         .    .    .         .     .    .         .     .     .            Index startRow, Index startCol,
         .    .    .         .     .    .         .     .     .            Index blockRows, Index blockCols)
    18,324   10    4     2,036     5    1         0     0     0        : Base(xpr.data()+xpr.innerStride()*(XprTypeIsRowMajor?startCol:startRow) + xpr.outerStride()*(XprTypeIsRowMajor?startRow:startCol), blockRows, blockCols),
 8,502,466   45   20   740,738     0    0 2,128,649 3,257 1,450          m_xpr(xpr), m_startRow(startRow), m_startCol(startCol)
         .    .    .         .     .    .         .     .     .      {
         .    .    .         .     .    .         .     .     .        init();
         .    .    .         .     .    .         .     .     .      }
         .    .    .         .     .    .         .     .     .  
         .    .    .         .     .    .         .     .     .      EIGEN_DEVICE_FUNC
         .    .    .         .     .    .         .     .     .      const typename internal::remove_all<XprTypeNested>::type& nestedExpression() const
         .    .    .         .     .    .         .     .     .      { 
         .    .    .         .     .    .         .     .     .        return m_xpr; 
-- line 383 ----------------------------------------
-- line 429 ----------------------------------------
         .    .    .         .     .    .         .     .     .        init();
         .    .    .         .     .    .         .     .     .      }
         .    .    .         .     .    .         .     .     .      #endif
         .    .    .         .     .    .         .     .     .  
         .    .    .         .     .    .         .     .     .    protected:
         .    .    .         .     .    .         .     .     .      EIGEN_DEVICE_FUNC
         .    .    .         .     .    .         .     .     .      void init()
         .    .    .         .     .    .         .     .     .      {
 4,544,189   85   36    14,164     0    0 4,530,025 3,503 1,661        m_outerStride = internal::traits<BlockType>::HasSameStorageOrderAsXprType
         .    .    .         .     .    .         .     .     .                      ? m_xpr.outerStride()
         .    .    .         .     .    .         .     .     .                      : m_xpr.innerStride();
         .    .    .         .     .    .         .     .     .      }
         .    .    .         .     .    .         .     .     .  
         .    .    .         .     .    .         .     .     .      XprTypeNested m_xpr;
         .    .    .         .     .    .         .     .     .      const internal::variable_if_dynamic<StorageIndex, (XprType::RowsAtCompileTime == 1 && BlockRows==1) ? 0 : Dynamic> m_startRow;
         .    .    .         .     .    .         .     .     .      const internal::variable_if_dynamic<StorageIndex, (XprType::ColsAtCompileTime == 1 && BlockCols==1) ? 0 : Dynamic> m_startCol;
         .    .    .         .     .    .         .     .     .      Index m_outerStride;
-- line 445 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/renzo/repos/spack/opt/spack/linux-slackware14-core2/gcc-9.3.0/eigen-3.3.7-d3fwbpqkxuuxfzl43t63y74jaxvht3bx/include/eigen3/Eigen/src/Core/products/SelfadjointMatrixVector.h
--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr        D1mr   DLmr  Dw        D1mw   DLmw 

-- line 31 ----------------------------------------
          .    .    .         .      .     .         .      .    .    Index size,
          .    .    .         .      .     .         .      .    .    const Scalar*  lhs, Index lhsStride,
          .    .    .         .      .     .         .      .    .    const Scalar*  rhs,
          .    .    .         .      .     .         .      .    .    Scalar* res,
          .    .    .         .      .     .         .      .    .    Scalar alpha);
          .    .    .         .      .     .         .      .    .  };
          .    .    .         .      .     .         .      .    .  
          .    .    .         .      .     .         .      .    .  template<typename Scalar, typename Index, int StorageOrder, int UpLo, bool ConjugateLhs, bool ConjugateRhs, int Version>
     22,396    6    4         0      0     0    18,324      0    0  EIGEN_DONT_INLINE void selfadjoint_matrix_vector_product<Scalar,Index,StorageOrder,UpLo,ConjugateLhs,ConjugateRhs,Version>::run(
          .    .    .         .      .     .         .      .    .    Index size,
          .    .    .         .      .     .         .      .    .    const Scalar*  lhs, Index lhsStride,
          .    .    .         .      .     .         .      .    .    const Scalar*  rhs,
          .    .    .         .      .     .         .      .    .    Scalar* res,
          .    .    .         .      .     .         .      .    .    Scalar alpha)
          .    .    .         .      .     .         .      .    .  {
          .    .    .         .      .     .         .      .    .    typedef typename packet_traits<Scalar>::type Packet;
          .    .    .         .      .     .         .      .    .    typedef typename NumTraits<Scalar>::Real RealScalar;
-- line 47 ----------------------------------------
-- line 58 ----------------------------------------
          .    .    .         .      .     .         .      .    .    conj_helper<RealScalar,Scalar,false, ConjugateRhs> cjd;
          .    .    .         .      .     .         .      .    .  
          .    .    .         .      .     .         .      .    .    conj_helper<Packet,Packet,NumTraits<Scalar>::IsComplex && EIGEN_LOGICAL_XOR(ConjugateLhs,  IsRowMajor), ConjugateRhs> pcj0;
          .    .    .         .      .     .         .      .    .    conj_helper<Packet,Packet,NumTraits<Scalar>::IsComplex && EIGEN_LOGICAL_XOR(ConjugateLhs, !IsRowMajor), ConjugateRhs> pcj1;
          .    .    .         .      .     .         .      .    .  
          .    .    .         .      .     .         .      .    .    Scalar cjAlpha = ConjugateRhs ? numext::conj(alpha) : alpha;
          .    .    .         .      .     .         .      .    .  
          .    .    .         .      .     .         .      .    .  
      8,144    0    0         0      0     0         0      0    0    Index bound = (std::max)(Index(0),size-8) & 0xfffffffe;
          .    .    .         .      .     .         .      .    .    if (FirstTriangular)
          .    .    .         .      .     .         .      .    .      bound = size - bound;
          .    .    .         .      .     .         .      .    .  
     19,620    0    0         0      0     0     5,886      0    0    for (Index j=FirstTriangular ? bound : 0;
  2,056,956    7    4 1,023,462      0     0     2,036      0    0         j<(FirstTriangular ? size : bound);j+=2)
          .    .    .         .      .     .         .      .    .    {
          .    .    .         .      .     .         .      .    .      const Scalar* EIGEN_RESTRICT A0 = lhs + j*lhsStride;
          .    .    .         .      .     .         .      .    .      const Scalar* EIGEN_RESTRICT A1 = lhs + (j+1)*lhsStride;
          .    .    .         .      .     .         .      .    .  
  1,021,500    7    4   681,000      4     1         0      0    0      Scalar t0 = cjAlpha * rhs[j];
          .    .    .         .      .     .         .      .    .      Packet ptmp0 = pset1<Packet>(t0);
  1,702,500    0    0 1,021,500      0     0         0      0    0      Scalar t1 = cjAlpha * rhs[j+1];
          .    .    .         .      .     .         .      .    .      Packet ptmp1 = pset1<Packet>(t1);
          .    .    .         .      .     .         .      .    .  
          .    .    .         .      .     .         .      .    .      Scalar t2(0);
    681,000    7    4         0      0     0         0      0    0      Packet ptmp2 = pset1<Packet>(t2);
  1,021,550    0    0        10      0     0   340,510      0    0      Scalar t3(0);
    681,000    0    0         0      0     0         0      0    0      Packet ptmp3 = pset1<Packet>(t3);
          .    .    .         .      .     .         .      .    .  
  1,362,000    0    0         0      0     0   340,500      0    0      Index starti = FirstTriangular ? 0 : j+2;
          .    .    .         .      .     .         .      .    .      Index endi   = FirstTriangular ? j : size;
          .    .    .         .      .     .         .      .    .      Index alignedStart = (starti) + internal::first_default_aligned(&res[starti], endi-starti);
          .    .    .         .      .     .         .      .    .      Index alignedEnd = alignedStart + ((endi-alignedStart)/(PacketSize))*(PacketSize);
          .    .    .         .      .     .         .      .    .  
    681,000    0    0   340,500    264     0   340,500      0    0      res[j]   += cjd.pmul(numext::real(A0[j]), t0);
    681,000    0    0   340,500    262     0   340,500      0    0      res[j+1] += cjd.pmul(numext::real(A1[j+1]), t1);
          .    .    .         .      .     .         .      .    .      if(FirstTriangular)
          .    .    .         .      .     .         .      .    .      {
          .    .    .         .      .     .         .      .    .        res[j]   += cj0.pmul(A1[j],   t1);
          .    .    .         .      .     .         .      .    .        t3       += cj1.pmul(A1[j],   rhs[j]);
          .    .    .         .      .     .         .      .    .      }
          .    .    .         .      .     .         .      .    .      else
          .    .    .         .      .     .         .      .    .      {
    681,000    0    0         0      0     0   340,500      0    0        res[j+1] += cj0.pmul(A0[j+1],t0);
    340,500    0    0         0      0     0         0      0    0        t2 += cj1.pmul(A0[j+1], rhs[j+1]);
          .    .    .         .      .     .         .      .    .      }
          .    .    .         .      .     .         .      .    .  
  6,299,250   14    8   510,750      0     0   340,500      0    0      for (Index i=starti; i<alignedStart; ++i)
          .    .    .         .      .     .         .      .    .      {
    510,750    0    0   170,250      0     0   170,250      0    0        res[i] += cj0.pmul(A0[i], t0) + cj0.pmul(A1[i],t1);
    340,500    0    0   170,250    581     0         0      0    0        t2 += cj1.pmul(A0[i], rhs[i]);
    170,250    0    0         0      0     0         0      0    0        t3 += cj1.pmul(A1[i], rhs[i]);
          .    .    .         .      .     .         .      .    .      }
          .    .    .         .      .     .         .      .    .      // Yes this an optimization for gcc 4.3 and 4.4 (=> huge speed up)
          .    .    .         .      .     .         .      .    .      // gcc 4.2 does this optimization automatically.
    681,000    7    4         0      0     0         0      0    0      const Scalar* EIGEN_RESTRICT a0It  = A0  + alignedStart;
    340,500    0    0         0      0     0         0      0    0      const Scalar* EIGEN_RESTRICT a1It  = A1  + alignedStart;
    340,500    0    0         0      0     0         0      0    0      const Scalar* EIGEN_RESTRICT rhsIt = rhs + alignedStart;
    340,500    0    0         0      0     0         0      0    0            Scalar* EIGEN_RESTRICT resIt = res + alignedStart;
153,841,650    7    4         0      0     0         0      0    0      for (Index i=alignedStart; i<alignedEnd; i+=PacketSize)
          .    .    .         .      .     .         .      .    .      {
          .    .    .         .      .     .         .      .    .        Packet A0i = ploadu<Packet>(a0It);  a0It  += PacketSize;
          .    .    .         .      .     .         .      .    .        Packet A1i = ploadu<Packet>(a1It);  a1It  += PacketSize;
          .    .    .         .      .     .         .      .    .        Packet Bi  = ploadu<Packet>(rhsIt); rhsIt += PacketSize; // FIXME should be aligned in most cases
          .    .    .         .      .     .         .      .    .        Packet Xi  = pload <Packet>(resIt);
          .    .    .         .      .     .         .      .    .  
          .    .    .         .      .     .         .      .    .        Xi    = pcj0.pmadd(A0i,ptmp0, pcj0.pmadd(A1i,ptmp1,Xi));
          .    .    .         .      .     .         .      .    .        ptmp2 = pcj1.pmadd(A0i,  Bi, ptmp2);
          .    .    .         .      .     .         .      .    .        ptmp3 = pcj1.pmadd(A1i,  Bi, ptmp3);
          .    .    .         .      .     .         .      .    .        pstore(resIt,Xi); resIt += PacketSize;
          .    .    .         .      .     .         .      .    .      }
 11,620,792   14    8 2,043,000 17,822   265 1,021,500 18,906  273      for (Index i=alignedEnd; i<endi; i++)
          .    .    .         .      .     .         .      .    .      {
  1,021,500    0    0   340,500      0     0   340,500      0    0        res[i] += cj0.pmul(A0[i], t0) + cj0.pmul(A1[i],t1);
    681,000    0    0   340,500      0     0         0      0    0        t2 += cj1.pmul(A0[i], rhs[i]);
    340,500    0    0         0      0     0         0      0    0        t3 += cj1.pmul(A1[i], rhs[i]);
          .    .    .         .      .     .         .      .    .      }
          .    .    .         .      .     .         .      .    .  
  1,362,000    0    0   340,500  2,158     0   340,500      0    0      res[j]   += alpha * (t2 + predux(ptmp2));
  1,362,000    7    3   340,500    264     0   340,500      0    0      res[j+1] += alpha * (t3 + predux(ptmp3));
          .    .    .         .      .     .         .      .    .    }
      6,108    2    1     4,072      0     0         0      0    0    for (Index j=FirstTriangular ? 0 : bound;j<(FirstTriangular ? bound : size);j++)
          .    .    .         .      .     .         .      .    .    {
     53,117    0    0    19,063      0     0         0      0    0      const Scalar* EIGEN_RESTRICT A0 = lhs + j*lhsStride;
          .    .    .         .      .     .         .      .    .  
     34,054    0    0    17,027      0     0         0      0    0      Scalar t1 = cjAlpha * rhs[j];
     23,077    9    3         0      0     0         0      0    0      Scalar t2(0);
     36,090    0    0    17,027      0     0    17,027      0    0      res[j] += cjd.pmul(numext::real(A0[j]), t1);
  1,330,382   61   26   365,631      0     0     6,078      0    0      for (Index i=FirstTriangular ? 0 : j+1; i<(FirstTriangular ? j : size); i++)
          .    .    .         .      .     .         .      .    .      {
    119,472    2    1    37,860      0     0    37,860      0    0        res[i] += cj0.pmul(A0[i], t1);
     63,684    0    0         0      0     0         0      0    0        t2 += cj1.pmul(A0[i], rhs[i]);
          .    .    .         .      .     .         .      .    .      }
     68,108   10    5    17,027      0     0    17,027      0    0      res[j] += alpha * t2;
          .    .    .         .      .     .         .      .    .    }
     14,252    1    1    14,252  1,434   648         0      0    0  }
          .    .    .         .      .     .         .      .    .  
          .    .    .         .      .     .         .      .    .  } // end namespace internal 
          .    .    .         .      .     .         .      .    .  
          .    .    .         .      .     .         .      .    .  /***************************************************************************
          .    .    .         .      .     .         .      .    .  * Wrapper to product_selfadjoint_vector
          .    .    .         .      .     .         .      .    .  ***************************************************************************/
          .    .    .         .      .     .         .      .    .  
          .    .    .         .      .     .         .      .    .  namespace internal {
-- line 160 ----------------------------------------
-- line 170 ----------------------------------------
          .    .    .         .      .     .         .      .    .    
          .    .    .         .      .     .         .      .    .    typedef internal::blas_traits<Rhs> RhsBlasTraits;
          .    .    .         .      .     .         .      .    .    typedef typename RhsBlasTraits::DirectLinearAccessType ActualRhsType;
          .    .    .         .      .     .         .      .    .    typedef typename internal::remove_all<ActualRhsType>::type ActualRhsTypeCleaned;
          .    .    .         .      .     .         .      .    .  
          .    .    .         .      .     .         .      .    .    enum { LhsUpLo = LhsMode&(Upper|Lower) };
          .    .    .         .      .     .         .      .    .  
          .    .    .         .      .     .         .      .    .    template<typename Dest>
     16,288   20    8         0      0     0    12,216      0    0    static void run(Dest& dest, const Lhs &a_lhs, const Rhs &a_rhs, const Scalar& alpha)
          .    .    .         .      .     .         .      .    .    {
          .    .    .         .      .     .         .      .    .      typedef typename Dest::Scalar ResScalar;
          .    .    .         .      .     .         .      .    .      typedef typename Rhs::Scalar RhsScalar;
          .    .    .         .      .     .         .      .    .      typedef Map<Matrix<ResScalar,Dynamic,1>, EIGEN_PLAIN_ENUM_MIN(AlignedMax,internal::packet_traits<ResScalar>::size)> MappedDest;
          .    .    .         .      .     .         .      .    .      
      4,072    0    0     2,036      0     0         0      0    0      eigen_assert(dest.rows()==a_lhs.rows() && dest.cols()==a_rhs.cols());
          .    .    .         .      .     .         .      .    .  
          .    .    .         .      .     .         .      .    .      typename internal::add_const_on_value_type<ActualLhsType>::type lhs = LhsBlasTraits::extract(a_lhs);
          .    .    .         .      .     .         .      .    .      typename internal::add_const_on_value_type<ActualRhsType>::type rhs = RhsBlasTraits::extract(a_rhs);
          .    .    .         .      .     .         .      .    .  
      6,108    0    0     4,072      0     0         0      0    0      Scalar actualAlpha = alpha * LhsBlasTraits::extractScalarFactor(a_lhs)
          .    .    .         .      .     .         .      .    .                                 * RhsBlasTraits::extractScalarFactor(a_rhs);
          .    .    .         .      .     .         .      .    .  
          .    .    .         .      .     .         .      .    .      enum {
          .    .    .         .      .     .         .      .    .        EvalToDest = (Dest::InnerStrideAtCompileTime==1),
          .    .    .         .      .     .         .      .    .        UseRhs = (ActualRhsTypeCleaned::InnerStrideAtCompileTime==1)
          .    .    .         .      .     .         .      .    .      };
          .    .    .         .      .     .         .      .    .      
          .    .    .         .      .     .         .      .    .      internal::gemv_static_vector_if<ResScalar,Dest::SizeAtCompileTime,Dest::MaxSizeAtCompileTime,!EvalToDest> static_dest;
          .    .    .         .      .     .         .      .    .      internal::gemv_static_vector_if<RhsScalar,ActualRhsTypeCleaned::SizeAtCompileTime,ActualRhsTypeCleaned::MaxSizeAtCompileTime,!UseRhs> static_rhs;
          .    .    .         .      .     .         .      .    .  
     12,216   10    4     2,036      0     0         0      0    0      ei_declare_aligned_stack_constructed_variable(ResScalar,actualDestPtr,dest.size(),
          .    .    .         .      .     .         .      .    .                                                    EvalToDest ? dest.data() : static_dest.data());
          .    .    .         .      .     .         .      .    .                                                    
     10,180    0    0     4,072      0     0         0      0    0      ei_declare_aligned_stack_constructed_variable(RhsScalar,actualRhsPtr,rhs.size(),
          .    .    .         .      .     .         .      .    .          UseRhs ? const_cast<RhsScalar*>(rhs.data()) : static_rhs.data());
          .    .    .         .      .     .         .      .    .      
          .    .    .         .      .     .         .      .    .      if(!EvalToDest)
          .    .    .         .      .     .         .      .    .      {
          .    .    .         .      .     .         .      .    .        #ifdef EIGEN_DENSE_STORAGE_CTOR_PLUGIN
          .    .    .         .      .     .         .      .    .        Index size = dest.size();
          .    .    .         .      .     .         .      .    .        EIGEN_DENSE_STORAGE_CTOR_PLUGIN
          .    .    .         .      .     .         .      .    .        #endif
-- line 211 ----------------------------------------
-- line 219 ----------------------------------------
          .    .    .         .      .     .         .      .    .        EIGEN_DENSE_STORAGE_CTOR_PLUGIN
          .    .    .         .      .     .         .      .    .        #endif
          .    .    .         .      .     .         .      .    .        Map<typename ActualRhsTypeCleaned::PlainObject>(actualRhsPtr, rhs.size()) = rhs;
          .    .    .         .      .     .         .      .    .      }
          .    .    .         .      .     .         .      .    .        
          .    .    .         .      .     .         .      .    .        
          .    .    .         .      .     .         .      .    .      internal::selfadjoint_matrix_vector_product<Scalar, Index, (internal::traits<ActualLhsTypeCleaned>::Flags&RowMajorBit) ? RowMajor : ColMajor,
          .    .    .         .      .     .         .      .    .                                                  int(LhsUpLo), bool(LhsBlasTraits::NeedToConjugate), bool(RhsBlasTraits::NeedToConjugate)>::run
      8,144   10    4     4,072      0     0     2,036      0    0        (
          .    .    .         .      .     .         .      .    .          lhs.rows(),                             // size
          .    .    .         .      .     .         .      .    .          &lhs.coeffRef(0,0),  lhs.outerStride(), // lhs info
          .    .    .         .      .     .         .      .    .          actualRhsPtr,                           // rhs info
          .    .    .         .      .     .         .      .    .          actualDestPtr,                          // result info
          .    .    .         .      .     .         .      .    .          actualAlpha                             // scale factor
          .    .    .         .      .     .         .      .    .        );
          .    .    .         .      .     .         .      .    .      
          .    .    .         .      .     .         .      .    .      if(!EvalToDest)
          .    .    .         .      .     .         .      .    .        dest = MappedDest(actualDestPtr, dest.size());
     16,288    0    0    14,252  2,962 1,296         0      0    0    }
          .    .    .         .      .     .         .      .    .  };
          .    .    .         .      .     .         .      .    .  
          .    .    .         .      .     .         .      .    .  template<typename Lhs, typename Rhs, int RhsMode>
          .    .    .         .      .     .         .      .    .  struct selfadjoint_product_impl<Lhs,0,true,Rhs,RhsMode,false>
          .    .    .         .      .     .         .      .    .  {
          .    .    .         .      .     .         .      .    .    typedef typename Product<Lhs,Rhs>::Scalar Scalar;
          .    .    .         .      .     .         .      .    .    enum { RhsUpLo = RhsMode&(Upper|Lower)  };
          .    .    .         .      .     .         .      .    .  
-- line 245 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/renzo/repos/spack/opt/spack/linux-slackware14-core2/gcc-9.3.0/eigen-3.3.7-d3fwbpqkxuuxfzl43t63y74jaxvht3bx/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h
--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr        D1mr    DLmr    Dw        D1mw    DLmw    

-- line 17 ----------------------------------------
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .  template<typename _LhsScalar, typename _RhsScalar, bool _ConjLhs=false, bool _ConjRhs=false>
          .    .    .         .       .       .         .       .       .  class gebp_traits;
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .  /** \internal \returns b if a<=0, and returns a otherwise. */
          .    .    .         .       .       .         .       .       .  inline std::ptrdiff_t manage_caching_sizes_helper(std::ptrdiff_t a, std::ptrdiff_t b)
          .    .    .         .       .       .         .       .       .  {
          9    1    1         0       0       0         0       0       0    return a<=0 ? b : a;
          .    .    .         .       .       .         .       .       .  }
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .  #if EIGEN_ARCH_i386_OR_x86_64
          .    .    .         .       .       .         .       .       .  const std::ptrdiff_t defaultL1CacheSize = 32*1024;
          .    .    .         .       .       .         .       .       .  const std::ptrdiff_t defaultL2CacheSize = 256*1024;
          .    .    .         .       .       .         .       .       .  const std::ptrdiff_t defaultL3CacheSize = 2*1024*1024;
          .    .    .         .       .       .         .       .       .  #else
          .    .    .         .       .       .         .       .       .  const std::ptrdiff_t defaultL1CacheSize = 16*1024;
          .    .    .         .       .       .         .       .       .  const std::ptrdiff_t defaultL2CacheSize = 512*1024;
          .    .    .         .       .       .         .       .       .  const std::ptrdiff_t defaultL3CacheSize = 512*1024;
          .    .    .         .       .       .         .       .       .  #endif
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .  /** \internal */
          .    .    .         .       .       .         .       .       .  struct CacheSizes {
          6    0    0         0       0       0         5       1       1    CacheSizes(): m_l1(-1),m_l2(-1),m_l3(-1) {
          .    .    .         .       .       .         .       .       .      int l1CacheSize, l2CacheSize, l3CacheSize;
          .    .    .         .       .       .         .       .       .      queryCacheSizes(l1CacheSize, l2CacheSize, l3CacheSize);
          2    0    0         0       0       0         1       0       0      m_l1 = manage_caching_sizes_helper(l1CacheSize, defaultL1CacheSize);
          2    0    0         0       0       0         1       0       0      m_l2 = manage_caching_sizes_helper(l2CacheSize, defaultL2CacheSize);
          2    0    0         0       0       0         1       0       0      m_l3 = manage_caching_sizes_helper(l3CacheSize, defaultL3CacheSize);
          4    0    0         4       0       0         0       0       0    }
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .    std::ptrdiff_t m_l1;
          .    .    .         .       .       .         .       .       .    std::ptrdiff_t m_l2;
          .    .    .         .       .       .         .       .       .    std::ptrdiff_t m_l3;
          .    .    .         .       .       .         .       .       .  };
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .  /** \internal */
          .    .    .         .       .       .         .       .       .  inline void manage_caching_sizes(Action action, std::ptrdiff_t* l1, std::ptrdiff_t* l2, std::ptrdiff_t* l3)
          .    .    .         .       .       .         .       .       .  {
         81   10    6        24      17       8         3       0       0    static CacheSizes m_cacheSizes;
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .    if(action==SetAction)
          .    .    .         .       .       .         .       .       .    {
          .    .    .         .       .       .         .       .       .      // set the cpu cache size and cache all block sizes from a global cache size in byte
          .    .    .         .       .       .         .       .       .      eigen_internal_assert(l1!=0 && l2!=0);
          .    .    .         .       .       .         .       .       .      m_cacheSizes.m_l1 = *l1;
          .    .    .         .       .       .         .       .       .      m_cacheSizes.m_l2 = *l2;
          .    .    .         .       .       .         .       .       .      m_cacheSizes.m_l3 = *l3;
          .    .    .         .       .       .         .       .       .    }
          .    .    .         .       .       .         .       .       .    else if(action==GetAction)
          .    .    .         .       .       .         .       .       .    {
          .    .    .         .       .       .         .       .       .      eigen_internal_assert(l1!=0 && l2!=0);
         24    0    0        24      18       9         0       0       0      *l1 = m_cacheSizes.m_l1;
         24    0    0        24       0       0         0       0       0      *l2 = m_cacheSizes.m_l2;
         24    0    0        24       0       0         0       0       0      *l3 = m_cacheSizes.m_l3;
          .    .    .         .       .       .         .       .       .    }
          .    .    .         .       .       .         .       .       .    else
          .    .    .         .       .       .         .       .       .    {
          .    .    .         .       .       .         .       .       .      eigen_internal_assert(false);
          .    .    .         .       .       .         .       .       .    }
          .    .    .         .       .       .         .       .       .  }
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .  /* Helper for computeProductBlockingSizes.
-- line 80 ----------------------------------------
-- line 85 ----------------------------------------
          .    .    .         .       .       .         .       .       .   * parameters:
          .    .    .         .       .       .         .       .       .   * - the L1 and L2 cache sizes,
          .    .    .         .       .       .         .       .       .   * - the register level blocking sizes defined by gebp_traits,
          .    .    .         .       .       .         .       .       .   * - the number of scalars that fit into a packet (when vectorization is enabled).
          .    .    .         .       .       .         .       .       .   *
          .    .    .         .       .       .         .       .       .   * \sa setCpuCacheSizes */
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .  template<typename LhsScalar, typename RhsScalar, int KcFactor, typename Index>
        264    8    4         0       0       0       144       6       3  void evaluateProductBlockingSizesHeuristic(Index& k, Index& m, Index& n, Index num_threads = 1)
          .    .    .         .       .       .         .       .       .  {
          .    .    .         .       .       .         .       .       .    typedef gebp_traits<LhsScalar,RhsScalar> Traits;
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .    // Explanations:
          .    .    .         .       .       .         .       .       .    // Let's recall that the product algorithms form mc x kc vertical panels A' on the lhs and
          .    .    .         .       .       .         .       .       .    // kc x nc blocks B' on the rhs. B' has to fit into L2/L3 cache. Moreover, A' is processed
          .    .    .         .       .       .         .       .       .    // per mr x kc horizontal small panels where mr is the blocking size along the m dimension
          .    .    .         .       .       .         .       .       .    // at the register level. This small horizontal panel has to stay within L1 cache.
          .    .    .         .       .       .         .       .       .    std::ptrdiff_t l1, l2, l3;
          .    .    .         .       .       .         .       .       .    manage_caching_sizes(GetAction, &l1, &l2, &l3);
          .    .    .         .       .       .         .       .       .  
         48    0    0         0       0       0         0       0       0    if (num_threads > 1) {
          .    .    .         .       .       .         .       .       .      typedef typename Traits::ResScalar ResScalar;
          .    .    .         .       .       .         .       .       .      enum {
          .    .    .         .       .       .         .       .       .        kdiv = KcFactor * (Traits::mr * sizeof(LhsScalar) + Traits::nr * sizeof(RhsScalar)),
          .    .    .         .       .       .         .       .       .        ksub = Traits::mr * Traits::nr * sizeof(ResScalar),
          .    .    .         .       .       .         .       .       .        kr = 8,
          .    .    .         .       .       .         .       .       .        mr = Traits::mr,
          .    .    .         .       .       .         .       .       .        nr = Traits::nr
          .    .    .         .       .       .         .       .       .      };
-- line 113 ----------------------------------------
-- line 152 ----------------------------------------
          .    .    .         .       .       .         .       .       .      l2 = 32*1024;
          .    .    .         .       .       .         .       .       .      l3 = 512*1024;
          .    .    .         .       .       .         .       .       .  #endif
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .      // Early return for small problems because the computation below are time consuming for small problems.
          .    .    .         .       .       .         .       .       .      // Perhaps it would make more sense to consider k*n*m??
          .    .    .         .       .       .         .       .       .      // Note that for very tiny problem, this function should be bypassed anyway
          .    .    .         .       .       .         .       .       .      // because we use the coefficient-based implementation for them.
        168    0    0         0       0       0         0       0       0      if((numext::maxi)(k,(numext::maxi)(m,n))<48)
          .    .    .         .       .       .         .       .       .        return;
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .      typedef typename Traits::ResScalar ResScalar;
          .    .    .         .       .       .         .       .       .      enum {
          .    .    .         .       .       .         .       .       .        k_peeling = 8,
          .    .    .         .       .       .         .       .       .        k_div = KcFactor * (Traits::mr * sizeof(LhsScalar) + Traits::nr * sizeof(RhsScalar)),
          .    .    .         .       .       .         .       .       .        k_sub = Traits::mr * Traits::nr * sizeof(ResScalar)
          .    .    .         .       .       .         .       .       .      };
-- line 168 ----------------------------------------
-- line 169 ----------------------------------------
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .      // ---- 1st level of blocking on L1, yields kc ----
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .      // Blocking on the third dimension (i.e., k) is chosen so that an horizontal panel
          .    .    .         .       .       .         .       .       .      // of size mr x kc of the lhs plus a vertical panel of kc x nr of the rhs both fits within L1 cache.
          .    .    .         .       .       .         .       .       .      // We also include a register-level block of the result (mx x nr).
          .    .    .         .       .       .         .       .       .      // (In an ideal world only the lhs panel would stay in L1)
          .    .    .         .       .       .         .       .       .      // Moreover, kc has to be a multiple of 8 to be compatible with loop peeling, leading to a maximum blocking size of:
         75    0    0         0       0       0         0       0       0      const Index max_kc = numext::maxi<Index>(((l1-k_sub)/k_div) & (~(k_peeling-1)),1);
          .    .    .         .       .       .         .       .       .      const Index old_k = k;
        120    0    0         0       0       0        18       0       0      if(k>max_kc)
          .    .    .         .       .       .         .       .       .      {
          .    .    .         .       .       .         .       .       .        // We are really blocking on the third dimension:
          .    .    .         .       .       .         .       .       .        // -> reduce blocking size to make sure the last block is as large as possible
          .    .    .         .       .       .         .       .       .        //    while keeping the same number of sweeps over the result.
        102    2    2        12       0       0        18       0       0        k = (k%max_kc)==0 ? max_kc
         54    2    2         0       0       0         0       0       0                          : max_kc - k_peeling * ((max_kc-1-(k%max_kc))/(k_peeling*(k/max_kc+1)));
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .        eigen_internal_assert(((old_k/k) == (old_k/max_kc)) && "the number of sweeps has to remain the same");
          .    .    .         .       .       .         .       .       .      }
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .      // ---- 2nd level of blocking on max(L2,L3), yields nc ----
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .      // TODO find a reliable way to get the actual amount of cache per core to use for 2nd level blocking, that is:
          .    .    .         .       .       .         .       .       .      //      actual_l2 = max(l2, l3/nb_core_sharing_l3)
-- line 193 ----------------------------------------
-- line 201 ----------------------------------------
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .      // Here, nc is chosen such that a block of kc x nc of the rhs fit within half of L2.
          .    .    .         .       .       .         .       .       .      // The second half is implicitly reserved to access the result and lhs coefficients.
          .    .    .         .       .       .         .       .       .      // When k<max_kc, then nc can arbitrarily growth. In practice, it seems to be fruitful
          .    .    .         .       .       .         .       .       .      // to limit this growth: we bound nc to growth by a factor x1.5.
          .    .    .         .       .       .         .       .       .      // However, if the entire lhs block fit within L1, then we are not going to block on the rows at all,
          .    .    .         .       .       .         .       .       .      // and it becomes fruitful to keep the packed rhs blocks in L1 if there is enough remaining space.
          .    .    .         .       .       .         .       .       .      Index max_nc;
         45    0    0         0       0       0         0       0       0      const Index lhs_bytes = m * k * sizeof(LhsScalar);
         30    0    0         0       0       0         0       0       0      const Index remaining_l1 = l1- k_sub - lhs_bytes;
         30    5    4        15       0       0         0       0       0      if(remaining_l1 >= Index(Traits::nr*sizeof(RhsScalar))*k)
          .    .    .         .       .       .         .       .       .      {
          .    .    .         .       .       .         .       .       .        // L1 blocking
          .    .    .         .       .       .         .       .       .        max_nc = remaining_l1 / (k*sizeof(RhsScalar));
          .    .    .         .       .       .         .       .       .      }
          .    .    .         .       .       .         .       .       .      else
          .    .    .         .       .       .         .       .       .      {
          .    .    .         .       .       .         .       .       .        // L2 blocking
         87    5    4         0       0       0         0       0       0        max_nc = (3*actual_l2)/(2*2*max_kc*sizeof(RhsScalar));
          .    .    .         .       .       .         .       .       .      }
          .    .    .         .       .       .         .       .       .      // WARNING Below, we assume that Traits::nr is a power of two.
         45    0    0         0       0       0         0       0       0      Index nc = numext::mini<Index>(actual_l2/(2*k*sizeof(RhsScalar)), max_nc) & (~(Traits::nr-1));
         48    0    0         0       0       0         0       0       0      if(n>nc)
          .    .    .         .       .       .         .       .       .      {
          .    .    .         .       .       .         .       .       .        // We are really blocking over the columns:
          .    .    .         .       .       .         .       .       .        // -> reduce blocking size to make sure the last block is as large as possible
          .    .    .         .       .       .         .       .       .        //    while keeping the same number of sweeps over the packed lhs.
          .    .    .         .       .       .         .       .       .        //    Here we allow one more sweep if this gives us a perfect match, thus the commented "-1"
         24    0    0         0       0       0         6       0       0        n = (n%nc)==0 ? nc
         42    2    2         0       0       0         0       0       0                      : (nc - Traits::nr * ((nc/*-1*/-(n%nc))/(Traits::nr*(n/nc+1))));
          .    .    .         .       .       .         .       .       .      }
         18    3    2         0       0       0         0       0       0      else if(old_k==k)
          .    .    .         .       .       .         .       .       .      {
          .    .    .         .       .       .         .       .       .        // So far, no blocking at all, i.e., kc==k, and nc==n.
          .    .    .         .       .       .         .       .       .        // In this case, let's perform a blocking over the rows such that the packed lhs data is kept in cache L1/L2
          .    .    .         .       .       .         .       .       .        // TODO: part of this blocking strategy is now implemented within the kernel itself, so the L1-based heuristic here should be obsolete.
         18    0    0         0       0       0         0       0       0        Index problem_size = k*n*sizeof(LhsScalar);
          .    .    .         .       .       .         .       .       .        Index actual_lm = actual_l2;
          .    .    .         .       .       .         .       .       .        Index max_mc = m;
         18    0    0         0       0       0         0       0       0        if(problem_size<=1024)
          .    .    .         .       .       .         .       .       .        {
          .    .    .         .       .       .         .       .       .          // problem is small enough to keep in L1
          .    .    .         .       .       .         .       .       .          // Let's choose m such that lhs's block fit in 1/3 of L1
          .    .    .         .       .       .         .       .       .          actual_lm = l1;
          .    .    .         .       .       .         .       .       .        }
         42    3    2         0       0       0         0       0       0        else if(l3!=0 && problem_size<=32768)
          .    .    .         .       .       .         .       .       .        {
          .    .    .         .       .       .         .       .       .          // we have both L2 and L3, and problem is small enough to be kept in L2
          .    .    .         .       .       .         .       .       .          // Let's choose m such that lhs's block fit in 1/3 of L2
          .    .    .         .       .       .         .       .       .          actual_lm = l2;
          .    .    .         .       .       .         .       .       .          max_mc = (numext::mini<Index>)(576,max_mc);
          .    .    .         .       .       .         .       .       .        }
         63    3    2         9       0       0         0       0       0        Index mc = (numext::mini<Index>)(actual_lm/(3*k*sizeof(LhsScalar)), max_mc);
         54    0    0         0       0       0         0       0       0        if (mc > Traits::mr) mc -= mc % Traits::mr;
          .    .    .         .       .       .         .       .       .        else if (mc==0) return;
         36    0    0         0       0       0         9       0       0        m = (m%mc)==0 ? mc
          .    .    .         .       .       .         .       .       .                      : (mc - Traits::mr * ((mc/*-1*/-(m%mc))/(Traits::mr*(m/mc+1))));
          .    .    .         .       .       .         .       .       .      }
          .    .    .         .       .       .         .       .       .    }
        192    6    2       168       0       0         0       0       0  }
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .  template <typename Index>
          .    .    .         .       .       .         .       .       .  inline bool useSpecificBlockingSizes(Index& k, Index& m, Index& n)
          .    .    .         .       .       .         .       .       .  {
          .    .    .         .       .       .         .       .       .  #ifdef EIGEN_TEST_SPECIFIC_BLOCKING_SIZES
          .    .    .         .       .       .         .       .       .    if (EIGEN_TEST_SPECIFIC_BLOCKING_SIZES) {
          .    .    .         .       .       .         .       .       .      k = numext::mini<Index>(k, EIGEN_TEST_SPECIFIC_BLOCKING_SIZE_K);
          .    .    .         .       .       .         .       .       .      m = numext::mini<Index>(m, EIGEN_TEST_SPECIFIC_BLOCKING_SIZE_M);
-- line 268 ----------------------------------------
-- line 292 ----------------------------------------
          .    .    .         .       .       .         .       .       .    *   - or using fixed prescribed values (for testing purposes).
          .    .    .         .       .       .         .       .       .    *
          .    .    .         .       .       .         .       .       .    * \sa setCpuCacheSizes */
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .  template<typename LhsScalar, typename RhsScalar, int KcFactor, typename Index>
          .    .    .         .       .       .         .       .       .  void computeProductBlockingSizes(Index& k, Index& m, Index& n, Index num_threads = 1)
          .    .    .         .       .       .         .       .       .  {
          .    .    .         .       .       .         .       .       .    if (!useSpecificBlockingSizes(k, m, n)) {
        152   16    8         0       0       0        32       0       0      evaluateProductBlockingSizesHeuristic<LhsScalar, RhsScalar, KcFactor, Index>(k, m, n, num_threads);
          .    .    .         .       .       .         .       .       .    }
          .    .    .         .       .       .         .       .       .  }
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .  template<typename LhsScalar, typename RhsScalar, typename Index>
          .    .    .         .       .       .         .       .       .  inline void computeProductBlockingSizes(Index& k, Index& m, Index& n, Index num_threads = 1)
          .    .    .         .       .       .         .       .       .  {
          .    .    .         .       .       .         .       .       .    computeProductBlockingSizes<LhsScalar,RhsScalar,1,Index>(k, m, n, num_threads);
          .    .    .         .       .       .         .       .       .  }
-- line 308 ----------------------------------------
-- line 390 ----------------------------------------
          .    .    .         .       .       .         .       .       .    typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;
          .    .    .         .       .       .         .       .       .    typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;
          .    .    .         .       .       .         .       .       .    typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .    typedef ResPacket AccPacket;
          .    .    .         .       .       .         .       .       .    
          .    .    .         .       .       .         .       .       .    EIGEN_STRONG_INLINE void initAcc(AccPacket& p)
          .    .    .         .       .       .         .       .       .    {
  4,227,048    8    4         0       0       0         0       0       0      p = pset1<ResPacket>(ResScalar(0));
          .    .    .         .       .       .         .       .       .    }
          .    .    .         .       .       .         .       .       .    
          .    .    .         .       .       .         .       .       .    EIGEN_STRONG_INLINE void broadcastRhs(const RhsScalar* b, RhsPacket& b0, RhsPacket& b1, RhsPacket& b2, RhsPacket& b3)
          .    .    .         .       .       .         .       .       .    {
          .    .    .         .       .       .         .       .       .      pbroadcast4(b, b0, b1, b2, b3);
          .    .    .         .       .       .         .       .       .    }
          .    .    .         .       .       .         .       .       .    
          .    .    .         .       .       .         .       .       .  //   EIGEN_STRONG_INLINE void broadcastRhs(const RhsScalar* b, RhsPacket& b0, RhsPacket& b1)
-- line 406 ----------------------------------------
-- line 884 ----------------------------------------
          .    .    .         .       .       .         .       .       .    EIGEN_DONT_INLINE
          .    .    .         .       .       .         .       .       .    void operator()(const DataMapper& res, const LhsScalar* blockA, const RhsScalar* blockB,
          .    .    .         .       .       .         .       .       .                    Index rows, Index depth, Index cols, ResScalar alpha,
          .    .    .         .       .       .         .       .       .                    Index strideA=-1, Index strideB=-1, Index offsetA=0, Index offsetB=0);
          .    .    .         .       .       .         .       .       .  };
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .  template<typename LhsScalar, typename RhsScalar, typename Index, typename DataMapper, int mr, int nr, bool ConjugateLhs, bool ConjugateRhs>
          .    .    .         .       .       .         .       .       .  EIGEN_DONT_INLINE
        924   16    8         0       0       0       726       0       0  void gebp_kernel<LhsScalar,RhsScalar,Index,DataMapper,mr,nr,ConjugateLhs,ConjugateRhs>
          .    .    .         .       .       .         .       .       .    ::operator()(const DataMapper& res, const LhsScalar* blockA, const RhsScalar* blockB,
          .    .    .         .       .       .         .       .       .                 Index rows, Index depth, Index cols, ResScalar alpha,
          .    .    .         .       .       .         .       .       .                 Index strideA, Index strideB, Index offsetA, Index offsetB)
          .    .    .         .       .       .         .       .       .    {
          .    .    .         .       .       .         .       .       .      Traits traits;
          .    .    .         .       .       .         .       .       .      SwappedTraits straits;
          .    .    .         .       .       .         .       .       .      
          .    .    .         .       .       .         .       .       .      if(strideA==-1) strideA = depth;
          .    .    .         .       .       .         .       .       .      if(strideB==-1) strideB = depth;
          .    .    .         .       .       .         .       .       .      conj_helper<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs> cj;
        330    0    0         0       0       0        66       0       0      Index packet_cols4 = nr>=4 ? (cols/4) * 4 : 0;
          .    .    .         .       .       .         .       .       .      const Index peeled_mc3 = mr>=3*Traits::LhsProgress ? (rows/(3*LhsProgress))*(3*LhsProgress) : 0;
        264    8    4         0       0       0         0       0       0      const Index peeled_mc2 = mr>=2*Traits::LhsProgress ? peeled_mc3+((rows-peeled_mc3)/(2*LhsProgress))*(2*LhsProgress) : 0;
        330    0    0         0       0       0        66       0       0      const Index peeled_mc1 = mr>=1*Traits::LhsProgress ? (rows/(1*LhsProgress))*(1*LhsProgress) : 0;
          .    .    .         .       .       .         .       .       .      enum { pk = 8 }; // NOTE Such a large peeling factor is important for large matrices (~ +5% when >1000 on Haswell)
        132    0    0         0       0       0         0       0       0      const Index peeled_kc  = depth & ~(pk-1);
          .    .    .         .       .       .         .       .       .      const Index prefetch_res_offset = 32/sizeof(ResScalar);    
          .    .    .         .       .       .         .       .       .  //     const Index depth2     = depth & ~1;
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .      //---------- Process 3 * LhsProgress rows at once ----------
          .    .    .         .       .       .         .       .       .      // This corresponds to 3*LhsProgress x nr register blocks.
          .    .    .         .       .       .         .       .       .      // Usually, make sense only with FMA
          .    .    .         .       .       .         .       .       .      if(mr>=3*Traits::LhsProgress)
          .    .    .         .       .       .         .       .       .      {
-- line 916 ----------------------------------------
-- line 1150 ----------------------------------------
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .      //---------- Process 2 * LhsProgress rows at once ----------
          .    .    .         .       .       .         .       .       .      if(mr>=2*Traits::LhsProgress)
          .    .    .         .       .       .         .       .       .      {
          .    .    .         .       .       .         .       .       .        const Index l1 = defaultL1CacheSize; // in Bytes, TODO, l1 should be passed to this function.
          .    .    .         .       .       .         .       .       .        // The max(1, ...) here is needed because we may be using blocking params larger than what our known l1 cache size
          .    .    .         .       .       .         .       .       .        // suggests we should be using: either because our known l1 cache size is inaccurate (e.g. on Android, we can only guess),
          .    .    .         .       .       .         .       .       .        // or because we are testing specific blocking sizes.
        858    8    4         0       0       0       132      62      30        Index actual_panel_rows = (2*LhsProgress) * std::max<Index>(1,( (l1 - sizeof(ResScalar)*mr*nr - depth*nr*sizeof(RhsScalar)) / (depth * sizeof(LhsScalar) * 2*LhsProgress) ));
          .    .    .         .       .       .         .       .       .  
    120,624   32   16    59,355  15,998     160    17,496     166      99        for(Index i1=peeled_mc3; i1<peeled_mc2; i1+=actual_panel_rows)
          .    .    .         .       .       .         .       .       .        {
          .    .    .         .       .       .         .       .       .          Index actual_panel_end = (std::min)(i1+actual_panel_rows, peeled_mc2);
  9,255,432   16    8 2,714,232 114,990     122 2,174,766      83      45          for(Index j2=0; j2<packet_cols4; j2+=nr)
          .    .    .         .       .       .         .       .       .          {
  3,357,498    8    4 1,948,482   7,872      41         0       0       0            for(Index i=i1; i<actual_panel_end; i+=2*LhsProgress)
          .    .    .         .       .       .         .       .       .            {
          .    .    .         .       .       .         .       .       .            
          .    .    .         .       .       .         .       .       .            // We selected a 2*Traits::LhsProgress x nr micro block of res which is entirely
          .    .    .         .       .       .         .       .       .            // stored into 2 x nr registers.
          .    .    .         .       .       .         .       .       .            
  1,409,016    0    0         0       0       0         0       0       0            const LhsScalar* blA = &blockA[i*strideA+offsetA*(2*Traits::LhsProgress)];
          .    .    .         .       .       .         .       .       .            prefetch(&blA[0]);
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .            // gets res block as register
          .    .    .         .       .       .         .       .       .            AccPacket C0, C1, C2, C3,
          .    .    .         .       .       .         .       .       .                      C4, C5, C6, C7;
          .    .    .         .       .       .         .       .       .            traits.initAcc(C0); traits.initAcc(C1); traits.initAcc(C2); traits.initAcc(C3);
          .    .    .         .       .       .         .       .       .            traits.initAcc(C4); traits.initAcc(C5); traits.initAcc(C6); traits.initAcc(C7);
          .    .    .         .       .       .         .       .       .  
-- line 1179 ----------------------------------------
-- line 1187 ----------------------------------------
          .    .    .         .       .       .         .       .       .            r2.prefetch(prefetch_res_offset);
          .    .    .         .       .       .         .       .       .            r3.prefetch(prefetch_res_offset);
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .            // performs "inner" products
          .    .    .         .       .       .         .       .       .            const RhsScalar* blB = &blockB[j2*strideB+offsetB*nr];
          .    .    .         .       .       .         .       .       .            prefetch(&blB[0]);
          .    .    .         .       .       .         .       .       .            LhsPacket A0, A1;
          .    .    .         .       .       .         .       .       .  
119,975,316    8    4   704,508     880       0         0       0       0            for(Index k=0; k<peeled_kc; k+=pk)
          .    .    .         .       .       .         .       .       .            {
          .    .    .         .       .       .         .       .       .              EIGEN_ASM_COMMENT("begin gebp micro kernel 2pX4");
          .    .    .         .       .       .         .       .       .              RhsPacket B_0, B1, B2, B3, T0;
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .            // NOTE: the begin/end asm comments below work around bug 935!
          .    .    .         .       .       .         .       .       .            // but they are not enough for gcc>=6 without FMA (bug 1637)
          .    .    .         .       .       .         .       .       .            #if EIGEN_GNUC_AT_LEAST(6,0) && defined(EIGEN_VECTORIZE_SSE)
          .    .    .         .       .       .         .       .       .              #define EIGEN_GEBP_2PX4_SPILLING_WORKAROUND __asm__  ("" : [a0] "+x,m" (A0),[a1] "+x,m" (A1));
-- line 1203 ----------------------------------------
-- line 1228 ----------------------------------------
          .    .    .         .       .       .         .       .       .              EIGEN_GEBGP_ONESTEP(2);
          .    .    .         .       .       .         .       .       .              EIGEN_GEBGP_ONESTEP(3);
          .    .    .         .       .       .         .       .       .              internal::prefetch(blB+(48+16));
          .    .    .         .       .       .         .       .       .              EIGEN_GEBGP_ONESTEP(4);
          .    .    .         .       .       .         .       .       .              EIGEN_GEBGP_ONESTEP(5);
          .    .    .         .       .       .         .       .       .              EIGEN_GEBGP_ONESTEP(6);
          .    .    .         .       .       .         .       .       .              EIGEN_GEBGP_ONESTEP(7);
          .    .    .         .       .       .         .       .       .  
  4,227,048    0    0   704,508     896      12         0       0       0              blB += pk*4*RhsProgress;
 28,760,940    0    0         0       0       0         0       0       0              blA += pk*(2*Traits::LhsProgress);
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .              EIGEN_ASM_COMMENT("end gebp micro kernel 2pX4");
          .    .    .         .       .       .         .       .       .            }
          .    .    .         .       .       .         .       .       .            // process remaining peeled loop
  1,409,016    0    0         0       0       0         0       0       0            for(Index k=peeled_kc; k<depth; k++)
          .    .    .         .       .       .         .       .       .            {
          .    .    .         .       .       .         .       .       .              RhsPacket B_0, B1, B2, B3, T0;
          .    .    .         .       .       .         .       .       .              EIGEN_GEBGP_ONESTEP(0);
          .    .    .         .       .       .         .       .       .              blB += 4*RhsProgress;
          .    .    .         .       .       .         .       .       .              blA += 2*Traits::LhsProgress;
          .    .    .         .       .       .         .       .       .            }
          .    .    .         .       .       .         .       .       .  #undef EIGEN_GEBGP_ONESTEP
          .    .    .         .       .       .         .       .       .  
-- line 1250 ----------------------------------------
-- line 1275 ----------------------------------------
          .    .    .         .       .       .         .       .       .            r2.storePacket(0 * Traits::ResPacketSize, R0);
          .    .    .         .       .       .         .       .       .            r2.storePacket(1 * Traits::ResPacketSize, R1);
          .    .    .         .       .       .         .       .       .            r3.storePacket(0 * Traits::ResPacketSize, R2);
          .    .    .         .       .       .         .       .       .            r3.storePacket(1 * Traits::ResPacketSize, R3);
          .    .    .         .       .       .         .       .       .            }
          .    .    .         .       .       .         .       .       .          }
          .    .    .         .       .       .         .       .       .        
          .    .    .         .       .       .         .       .       .          // Deal with remaining columns of the rhs
     25,353    0    0    16,902   2,814      36         0       0       0          for(Index j2=packet_cols4; j2<cols; j2++)
          .    .    .         .       .       .         .       .       .          {
          .    .    .         .       .       .         .       .       .            for(Index i=i1; i<actual_panel_end; i+=2*LhsProgress)
          .    .    .         .       .       .         .       .       .            {
          .    .    .         .       .       .         .       .       .            // One column at a time
          .    .    .         .       .       .         .       .       .            const LhsScalar* blA = &blockA[i*strideA+offsetA*(2*Traits::LhsProgress)];
          .    .    .         .       .       .         .       .       .            prefetch(&blA[0]);
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .            // gets res block as register
-- line 1291 ----------------------------------------
-- line 1353 ----------------------------------------
          .    .    .         .       .       .         .       .       .            }
          .    .    .         .       .       .         .       .       .          }
          .    .    .         .       .       .         .       .       .        }
          .    .    .         .       .       .         .       .       .      }
          .    .    .         .       .       .         .       .       .      //---------- Process 1 * LhsProgress rows at once ----------
          .    .    .         .       .       .         .       .       .      if(mr>=1*Traits::LhsProgress)
          .    .    .         .       .       .         .       .       .      {
          .    .    .         .       .       .         .       .       .        // loops on each largest micro horizontal panel of lhs (1*LhsProgress x depth)
        198    0    0       132      38       0         0       0       0        for(Index i=peeled_mc2; i<peeled_mc1; i+=1*LhsProgress)
          .    .    .         .       .       .         .       .       .        {
          .    .    .         .       .       .         .       .       .          // loops on each largest micro vertical panel of rhs (depth * nr)
          .    .    .         .       .       .         .       .       .          for(Index j2=0; j2<packet_cols4; j2+=nr)
          .    .    .         .       .       .         .       .       .          {
          .    .    .         .       .       .         .       .       .            // We select a 1*Traits::LhsProgress x nr micro block of res which is entirely
          .    .    .         .       .       .         .       .       .            // stored into 1 x nr registers.
          .    .    .         .       .       .         .       .       .            
          .    .    .         .       .       .         .       .       .            const LhsScalar* blA = &blockA[i*strideA+offsetA*(1*Traits::LhsProgress)];
-- line 1369 ----------------------------------------
-- line 1513 ----------------------------------------
          .    .    .         .       .       .         .       .       .            ResPacket alphav = pset1<ResPacket>(alpha);
          .    .    .         .       .       .         .       .       .            R0 = r0.loadPacket(0 * Traits::ResPacketSize);
          .    .    .         .       .       .         .       .       .            traits.acc(C0, alphav, R0);
          .    .    .         .       .       .         .       .       .            r0.storePacket(0 * Traits::ResPacketSize, R0);
          .    .    .         .       .       .         .       .       .          }
          .    .    .         .       .       .         .       .       .        }
          .    .    .         .       .       .         .       .       .      }
          .    .    .         .       .       .         .       .       .      //---------- Process remaining rows, 1 at once ----------
        198    8    4       132      19      17         0       0       0      if(peeled_mc1<rows)
          .    .    .         .       .       .         .       .       .      {
          .    .    .         .       .       .         .       .       .        // loop on each panel of the rhs
          .    .    .         .       .       .         .       .       .        for(Index j2=0; j2<packet_cols4; j2+=nr)
          .    .    .         .       .       .         .       .       .        {
          .    .    .         .       .       .         .       .       .          // loop on each row of the lhs (1*LhsProgress x depth)
          .    .    .         .       .       .         .       .       .          for(Index i=peeled_mc1; i<rows; i+=1)
          .    .    .         .       .       .         .       .       .          {
          .    .    .         .       .       .         .       .       .            const LhsScalar* blA = &blockA[i*strideA+offsetA];
-- line 1529 ----------------------------------------
-- line 1668 ----------------------------------------
          .    .    .         .       .       .         .       .       .              LhsScalar A0 = blA[k];
          .    .    .         .       .       .         .       .       .              RhsScalar B_0 = blB[k];
          .    .    .         .       .       .         .       .       .              CJMADD(cj, A0, B_0, C0, B_0);
          .    .    .         .       .       .         .       .       .            }
          .    .    .         .       .       .         .       .       .            res(i, j2) += alpha * C0;
          .    .    .         .       .       .         .       .       .          }
          .    .    .         .       .       .         .       .       .        }
          .    .    .         .       .       .         .       .       .      }
        528   16    8       462      95      82         0       0       0    }
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .  #undef CJMADD
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .  // pack a block of the lhs
          .    .    .         .       .       .         .       .       .  // The traversal is as follow (mr==4):
          .    .    .         .       .       .         .       .       .  //   0  4  8 12 ...
          .    .    .         .       .       .         .       .       .  //   1  5  9 13 ...
-- line 1684 ----------------------------------------
-- line 1695 ----------------------------------------
          .    .    .         .       .       .         .       .       .  template<typename Scalar, typename Index, typename DataMapper, int Pack1, int Pack2, bool Conjugate, bool PanelMode>
          .    .    .         .       .       .         .       .       .  struct gemm_pack_lhs<Scalar, Index, DataMapper, Pack1, Pack2, ColMajor, Conjugate, PanelMode>
          .    .    .         .       .       .         .       .       .  {
          .    .    .         .       .       .         .       .       .    typedef typename DataMapper::LinearMapper LinearMapper;
          .    .    .         .       .       .         .       .       .    EIGEN_DONT_INLINE void operator()(Scalar* blockA, const DataMapper& lhs, Index depth, Index rows, Index stride=0, Index offset=0);
          .    .    .         .       .       .         .       .       .  };
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .  template<typename Scalar, typename Index, typename DataMapper, int Pack1, int Pack2, bool Conjugate, bool PanelMode>
        198    8    4         0       0       0       198       6       3  EIGEN_DONT_INLINE void gemm_pack_lhs<Scalar, Index, DataMapper, Pack1, Pack2, ColMajor, Conjugate, PanelMode>
          .    .    .         .       .       .         .       .       .    ::operator()(Scalar* blockA, const DataMapper& lhs, Index depth, Index rows, Index stride, Index offset)
          .    .    .         .       .       .         .       .       .  {
          .    .    .         .       .       .         .       .       .    typedef typename packet_traits<Scalar>::type Packet;
          .    .    .         .       .       .         .       .       .    enum { PacketSize = packet_traits<Scalar>::size };
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .    EIGEN_ASM_COMMENT("EIGEN PRODUCT PACK LHS");
          .    .    .         .       .       .         .       .       .    EIGEN_UNUSED_VARIABLE(stride);
          .    .    .         .       .       .         .       .       .    EIGEN_UNUSED_VARIABLE(offset);
          .    .    .         .       .       .         .       .       .    eigen_assert(((!PanelMode) && stride==0 && offset==0) || (PanelMode && stride>=depth && offset<=stride));
          .    .    .         .       .       .         .       .       .    eigen_assert( ((Pack1%PacketSize)==0 && Pack1<=4*PacketSize) || (Pack1<=4) );
          .    .    .         .       .       .         .       .       .    conj_if<NumTraits<Scalar>::IsComplex && Conjugate> cj;
         33    0    0         0       0       0         0       0       0    Index count = 0;
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .    const Index peeled_mc3 = Pack1>=3*PacketSize ? (rows/(3*PacketSize))*(3*PacketSize) : 0;
         99    0    0         0       0       0         0       0       0    const Index peeled_mc2 = Pack1>=2*PacketSize ? peeled_mc3+((rows-peeled_mc3)/(2*PacketSize))*(2*PacketSize) : 0;
        132    6    4         0       0       0         0       0       0    const Index peeled_mc1 = Pack1>=1*PacketSize ? (rows/(1*PacketSize))*(1*PacketSize) : 0;
          .    .    .         .       .       .         .       .       .    const Index peeled_mc0 = Pack2>=1*PacketSize ? peeled_mc1
          .    .    .         .       .       .         .       .       .                           : Pack2>1             ? (rows/Pack2)*Pack2 : 0;
          .    .    .         .       .       .         .       .       .  
         66    0    0         0       0       0         0       0       0    Index i=0;
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .    // Pack 3 packets
          .    .    .         .       .       .         .       .       .    if(Pack1>=3*PacketSize)
          .    .    .         .       .       .         .       .       .    {
          .    .    .         .       .       .         .       .       .      for(; i<peeled_mc3; i+=3*PacketSize)
          .    .    .         .       .       .         .       .       .      {
          .    .    .         .       .       .         .       .       .        if(PanelMode) count += (3*PacketSize) * offset;
          .    .    .         .       .       .         .       .       .  
-- line 1731 ----------------------------------------
-- line 1740 ----------------------------------------
          .    .    .         .       .       .         .       .       .          pstore(blockA+count, cj.pconj(C)); count+=PacketSize;
          .    .    .         .       .       .         .       .       .        }
          .    .    .         .       .       .         .       .       .        if(PanelMode) count += (3*PacketSize) * (stride-offset-depth);
          .    .    .         .       .       .         .       .       .      }
          .    .    .         .       .       .         .       .       .    }
          .    .    .         .       .       .         .       .       .    // Pack 2 packets
          .    .    .         .       .       .         .       .       .    if(Pack1>=2*PacketSize)
          .    .    .         .       .       .         .       .       .    {
     10,515    0    0         0       0       0         0       0       0      for(; i<peeled_mc2; i+=2*PacketSize)
          .    .    .         .       .       .         .       .       .      {
          .    .    .         .       .       .         .       .       .        if(PanelMode) count += (2*PacketSize) * offset;
          .    .    .         .       .       .         .       .       .  
  3,166,380    8    4         0       0       0         0       0       0        for(Index k=0; k<depth; k++)
          .    .    .         .       .       .         .       .       .        {
          .    .    .         .       .       .         .       .       .          Packet A, B;
          .    .    .         .       .       .         .       .       .          A = lhs.loadPacket(i+0*PacketSize, k);
          .    .    .         .       .       .         .       .       .          B = lhs.loadPacket(i+1*PacketSize, k);
          .    .    .         .       .       .         .       .       .          pstore(blockA+count, cj.pconj(A)); count+=PacketSize;
          .    .    .         .       .       .         .       .       .          pstore(blockA+count, cj.pconj(B)); count+=PacketSize;
          .    .    .         .       .       .         .       .       .        }
          .    .    .         .       .       .         .       .       .        if(PanelMode) count += (2*PacketSize) * (stride-offset-depth);
          .    .    .         .       .       .         .       .       .      }
          .    .    .         .       .       .         .       .       .    }
          .    .    .         .       .       .         .       .       .    // Pack 1 packets
          .    .    .         .       .       .         .       .       .    if(Pack1>=1*PacketSize)
          .    .    .         .       .       .         .       .       .    {
        132    8    4         0       0       0         0       0       0      for(; i<peeled_mc1; i+=1*PacketSize)
          .    .    .         .       .       .         .       .       .      {
          .    .    .         .       .       .         .       .       .        if(PanelMode) count += (1*PacketSize) * offset;
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .        for(Index k=0; k<depth; k++)
          .    .    .         .       .       .         .       .       .        {
          .    .    .         .       .       .         .       .       .          Packet A;
          .    .    .         .       .       .         .       .       .          A = lhs.loadPacket(i+0*PacketSize, k);
          .    .    .         .       .       .         .       .       .          pstore(blockA+count, cj.pconj(A));
-- line 1774 ----------------------------------------
-- line 1786 ----------------------------------------
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .        for(Index k=0; k<depth; k++)
          .    .    .         .       .       .         .       .       .          for(Index w=0; w<Pack2; w++)
          .    .    .         .       .       .         .       .       .            blockA[count++] = cj(lhs(i+w, k));
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .        if(PanelMode) count += Pack2 * (stride-offset-depth);
          .    .    .         .       .       .         .       .       .      }
          .    .    .         .       .       .         .       .       .    }
         66    8    4         0       0       0         0       0       0    for(; i<rows; i++)
          .    .    .         .       .       .         .       .       .    {
          .    .    .         .       .       .         .       .       .      if(PanelMode) count += offset;
          .    .    .         .       .       .         .       .       .      for(Index k=0; k<depth; k++)
          .    .    .         .       .       .         .       .       .        blockA[count++] = cj(lhs(i, k));
          .    .    .         .       .       .         .       .       .      if(PanelMode) count += (stride-offset-depth);
          .    .    .         .       .       .         .       .       .    }
        231    8    4       231      40      25         0       0       0  }
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .  template<typename Scalar, typename Index, typename DataMapper, int Pack1, int Pack2, bool Conjugate, bool PanelMode>
          .    .    .         .       .       .         .       .       .  struct gemm_pack_lhs<Scalar, Index, DataMapper, Pack1, Pack2, RowMajor, Conjugate, PanelMode>
          .    .    .         .       .       .         .       .       .  {
          .    .    .         .       .       .         .       .       .    typedef typename DataMapper::LinearMapper LinearMapper;
          .    .    .         .       .       .         .       .       .    EIGEN_DONT_INLINE void operator()(Scalar* blockA, const DataMapper& lhs, Index depth, Index rows, Index stride=0, Index offset=0);
          .    .    .         .       .       .         .       .       .  };
          .    .    .         .       .       .         .       .       .  
-- line 1809 ----------------------------------------
-- line 1899 ----------------------------------------
          .    .    .         .       .       .         .       .       .  {
          .    .    .         .       .       .         .       .       .    typedef typename packet_traits<Scalar>::type Packet;
          .    .    .         .       .       .         .       .       .    typedef typename DataMapper::LinearMapper LinearMapper;
          .    .    .         .       .       .         .       .       .    enum { PacketSize = packet_traits<Scalar>::size };
          .    .    .         .       .       .         .       .       .    EIGEN_DONT_INLINE void operator()(Scalar* blockB, const DataMapper& rhs, Index depth, Index cols, Index stride=0, Index offset=0);
          .    .    .         .       .       .         .       .       .  };
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .  template<typename Scalar, typename Index, typename DataMapper, int nr, bool Conjugate, bool PanelMode>
        660    0    0         0       0       0       594      34      23  EIGEN_DONT_INLINE void gemm_pack_rhs<Scalar, Index, DataMapper, nr, ColMajor, Conjugate, PanelMode>
          .    .    .         .       .       .         .       .       .    ::operator()(Scalar* blockB, const DataMapper& rhs, Index depth, Index cols, Index stride, Index offset)
          .    .    .         .       .       .         .       .       .  {
          .    .    .         .       .       .         .       .       .    EIGEN_ASM_COMMENT("EIGEN PRODUCT PACK RHS COLMAJOR");
          .    .    .         .       .       .         .       .       .    EIGEN_UNUSED_VARIABLE(stride);
          .    .    .         .       .       .         .       .       .    EIGEN_UNUSED_VARIABLE(offset);
          .    .    .         .       .       .         .       .       .    eigen_assert(((!PanelMode) && stride==0 && offset==0) || (PanelMode && stride>=depth && offset<=stride));
          .    .    .         .       .       .         .       .       .    conj_if<NumTraits<Scalar>::IsComplex && Conjugate> cj;
          .    .    .         .       .       .         .       .       .    Index packet_cols8 = nr>=8 ? (cols/8) * 8 : 0;
        198    8    4         0       0       0         0       0       0    Index packet_cols4 = nr>=4 ? (cols/4) * 4 : 0;
         66    0    0         0       0       0        66      26      19    Index count = 0;
          .    .    .         .       .       .         .       .       .    const Index peeled_k = (depth/PacketSize)*PacketSize;
          .    .    .         .       .       .         .       .       .  //   if(nr>=8)
          .    .    .         .       .       .         .       .       .  //   {
          .    .    .         .       .       .         .       .       .  //     for(Index j2=0; j2<packet_cols8; j2+=8)
          .    .    .         .       .       .         .       .       .  //     {
          .    .    .         .       .       .         .       .       .  //       // skip what we have before
          .    .    .         .       .       .         .       .       .  //       if(PanelMode) count += 8 * offset;
          .    .    .         .       .       .         .       .       .  //       const Scalar* b0 = &rhs[(j2+0)*rhsStride];
-- line 1925 ----------------------------------------
-- line 1959 ----------------------------------------
          .    .    .         .       .       .         .       .       .  //       }
          .    .    .         .       .       .         .       .       .  //       // skip what we have after
          .    .    .         .       .       .         .       .       .  //       if(PanelMode) count += 8 * (stride-offset-depth);
          .    .    .         .       .       .         .       .       .  //     }
          .    .    .         .       .       .         .       .       .  //   }
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .    if(nr>=4)
          .    .    .         .       .       .         .       .       .    {
     28,128    8    4    17,250       0       0       132       0       0      for(Index j2=packet_cols8; j2<packet_cols4; j2+=4)
          .    .    .         .       .       .         .       .       .      {
          .    .    .         .       .       .         .       .       .        // skip what we have before
          .    .    .         .       .       .         .       .       .        if(PanelMode) count += 4 * offset;
          .    .    .         .       .       .         .       .       .        const LinearMapper dm0 = rhs.getLinearMapper(0, j2 + 0);
          .    .    .         .       .       .         .       .       .        const LinearMapper dm1 = rhs.getLinearMapper(0, j2 + 1);
          .    .    .         .       .       .         .       .       .        const LinearMapper dm2 = rhs.getLinearMapper(0, j2 + 2);
          .    .    .         .       .       .         .       .       .        const LinearMapper dm3 = rhs.getLinearMapper(0, j2 + 3);
          .    .    .         .       .       .         .       .       .  
-- line 1975 ----------------------------------------
-- line 1985 ----------------------------------------
          .    .    .         .       .       .         .       .       .            ptranspose(kernel);
          .    .    .         .       .       .         .       .       .            pstoreu(blockB+count+0*PacketSize, cj.pconj(kernel.packet[0]));
          .    .    .         .       .       .         .       .       .            pstoreu(blockB+count+1*PacketSize, cj.pconj(kernel.packet[1%PacketSize]));
          .    .    .         .       .       .         .       .       .            pstoreu(blockB+count+2*PacketSize, cj.pconj(kernel.packet[2%PacketSize]));
          .    .    .         .       .       .         .       .       .            pstoreu(blockB+count+3*PacketSize, cj.pconj(kernel.packet[3%PacketSize]));
          .    .    .         .       .       .         .       .       .            count+=4*PacketSize;
          .    .    .         .       .       .         .       .       .          }
          .    .    .         .       .       .         .       .       .        }
  1,766,040   48   24    72,450       0       0    20,700       0       0        for(; k<depth; k++)
          .    .    .         .       .       .         .       .       .        {
          .    .    .         .       .       .         .       .       .          blockB[count+0] = cj(dm0(k));
          .    .    .         .       .       .         .       .       .          blockB[count+1] = cj(dm1(k));
          .    .    .         .       .       .         .       .       .          blockB[count+2] = cj(dm2(k));
  9,437,040    8    4 4,194,240 536,199 506,615 2,097,120 524,017 193,475          blockB[count+3] = cj(dm3(k));
          .    .    .         .       .       .         .       .       .          count += 4;
          .    .    .         .       .       .         .       .       .        }
          .    .    .         .       .       .         .       .       .        // skip what we have after
          .    .    .         .       .       .         .       .       .        if(PanelMode) count += 4 * (stride-offset-depth);
          .    .    .         .       .       .         .       .       .      }
          .    .    .         .       .       .         .       .       .    }
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .    // copy the remaining columns one at a time (nr==1)
        198    0    0       132       0       0         0       0       0    for(Index j2=packet_cols4; j2<cols; ++j2)
          .    .    .         .       .       .         .       .       .    {
          .    .    .         .       .       .         .       .       .      if(PanelMode) count += offset;
          .    .    .         .       .       .         .       .       .      const LinearMapper dm0 = rhs.getLinearMapper(0, j2);
          .    .    .         .       .       .         .       .       .      for(Index k=0; k<depth; k++)
          .    .    .         .       .       .         .       .       .      {
          .    .    .         .       .       .         .       .       .        blockB[count] = cj(dm0(k));
          .    .    .         .       .       .         .       .       .        count += 1;
          .    .    .         .       .       .         .       .       .      }
          .    .    .         .       .       .         .       .       .      if(PanelMode) count += (stride-offset-depth);
          .    .    .         .       .       .         .       .       .    }
        528   16    8       462      57      12         0       0       0  }
          .    .    .         .       .       .         .       .       .  
          .    .    .         .       .       .         .       .       .  // this version is optimized for row major matrices
          .    .    .         .       .       .         .       .       .  template<typename Scalar, typename Index, typename DataMapper, int nr, bool Conjugate, bool PanelMode>
          .    .    .         .       .       .         .       .       .  struct gemm_pack_rhs<Scalar, Index, DataMapper, nr, RowMajor, Conjugate, PanelMode>
          .    .    .         .       .       .         .       .       .  {
          .    .    .         .       .       .         .       .       .    typedef typename packet_traits<Scalar>::type Packet;
          .    .    .         .       .       .         .       .       .    typedef typename DataMapper::LinearMapper LinearMapper;
          .    .    .         .       .       .         .       .       .    enum { PacketSize = packet_traits<Scalar>::size };
-- line 2026 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/lib64/gcc/x86_64-slackware-linux/9.3.0/include/xmmintrin.h
--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 46 ----------------------------------------
         .    .    .  .    .    .  .    .    .  };
         .    .    .  .    .    .  .    .    .  
         .    .    .  .    .    .  .    .    .  /* Loads one cache line from address P to a location "closer" to the
         .    .    .  .    .    .  .    .    .     processor.  The selector I specifies the type of prefetch operation.  */
         .    .    .  .    .    .  .    .    .  #ifdef __OPTIMIZE__
         .    .    .  .    .    .  .    .    .  extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
         .    .    .  .    .    .  .    .    .  _mm_prefetch (const void *__P, enum _mm_hint __I)
         .    .    .  .    .    .  .    .    .  {
61,748,928    0    0  0    0    0  0    0    0    __builtin_prefetch (__P, (__I & 0x4) >> 2, __I & 0x3);
         .    .    .  .    .    .  .    .    .  }
         .    .    .  .    .    .  .    .    .  #else
         .    .    .  .    .    .  .    .    .  #define _mm_prefetch(P, I) \
         .    .    .  .    .    .  .    .    .    __builtin_prefetch ((P), ((I & 0x4) >> 2), (I & 0x3))
         .    .    .  .    .    .  .    .    .  #endif
         .    .    .  .    .    .  .    .    .  
         .    .    .  .    .    .  .    .    .  #ifndef __SSE__
         .    .    .  .    .    .  .    .    .  #pragma GCC push_options
-- line 62 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/lib64/gcc/x86_64-slackware-linux/9.3.0/include/emmintrin.h
--------------------------------------------------------------------------------
Ir            I1mr ILmr Dr          D1mr       DLmr       Dw          D1mw    DLmw    

-- line 67 ----------------------------------------
            .    .    .           .          .          .           .       .       .  {
            .    .    .           .          .          .           .       .       .    return __extension__ (__m128d){ __F, 0.0 };
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  /* Create a vector with both elements equal to F.  */
            .    .    .           .          .          .           .       .       .  extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_set1_pd (double __F)
            .    .    .           .          .          .           .       .       .  {
    1,702,716   11    6         108          0          0           0       0       0    return __extension__ (__m128d){ __F, __F };
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_set_pd1 (double __F)
            .    .    .           .          .          .           .       .       .  {
            .    .    .           .          .          .           .       .       .    return _mm_set1_pd (__F);
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
-- line 83 ----------------------------------------
-- line 116 ----------------------------------------
            .    .    .           .          .          .           .       .       .  {
            .    .    .           .          .          .           .       .       .    return __extension__ (__m128d) __builtin_shuffle ((__v2df)__A, (__v2df)__B, (__v2di){2, 1});
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  /* Load two DPFP values from P.  The address must be 16-byte aligned.  */
            .    .    .           .          .          .           .       .       .  extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_load_pd (double const *__P)
            .    .    .           .          .          .           .       .       .  {
  510,956,760    8    4 510,956,760 42,093,566  1,833,274           0       0       0    return *(__m128d *)__P;
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  /* Load two DPFP values from P.  The address need not be 16-byte aligned.  */
            .    .    .           .          .          .           .       .       .  extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_loadu_pd (double const *__P)
            .    .    .           .          .          .           .       .       .  {
    3,808,938   25   12   2,760,378  1,724,392  1,377,997   1,048,560 172,032 172,032    return *(__m128d_u *)__P;
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  /* Create a vector with all two elements equal to *P.  */
            .    .    .           .          .          .           .       .       .  extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_load1_pd (double const *__P)
            .    .    .           .          .          .           .       .       .  {
            .    .    .           .          .          .           .       .       .    return _mm_set1_pd (*__P);
            .    .    .           .          .          .           .       .       .  }
-- line 139 ----------------------------------------
-- line 158 ----------------------------------------
            .    .    .           .          .          .           .       .       .    __m128d __tmp = _mm_load_pd (__P);
            .    .    .           .          .          .           .       .       .    return __builtin_ia32_shufpd (__tmp, __tmp, _MM_SHUFFLE2 (0,1));
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  /* Store two DPFP values.  The address must be 16-byte aligned.  */
            .    .    .           .          .          .           .       .       .  extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_store_pd (double *__P, __m128d __A)
            .    .    .           .          .          .           .       .       .  {
  359,855,856   37   14      10,187         35         14 359,803,034 603,080 544,970    *(__m128d *)__P = __A;
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  /* Store two DPFP values.  The address need not be 16-byte aligned.  */
            .    .    .           .          .          .           .       .       .  extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_storeu_pd (double *__P, __m128d __A)
            .    .    .           .          .          .           .       .       .  {
    6,956,572    8    4     660,254    143,467     70,557   6,296,318       0       0    *(__m128d_u *)__P = __A;
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  /* Stores the lower DPFP value.  */
            .    .    .           .          .          .           .       .       .  extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_store_sd (double *__P, __m128d __A)
            .    .    .           .          .          .           .       .       .  {
            .    .    .           .          .          .           .       .       .    *__P = ((__v2df)__A)[0];
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  extern __inline double __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_cvtsd_f64 (__m128d __A)
            .    .    .           .          .          .           .       .       .  {
      681,000    0    0     340,500          0          0           0       0       0    return ((__v2df)__A)[0];
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_storel_pd (double *__P, __m128d __A)
            .    .    .           .          .          .           .       .       .  {
            .    .    .           .          .          .           .       .       .    _mm_store_sd (__P, __A);
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
-- line 194 ----------------------------------------
-- line 240 ----------------------------------------
            .    .    .           .          .          .           .       .       .  {
            .    .    .           .          .          .           .       .       .    return ((__v2di)__A)[0];
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  #endif
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_add_pd (__m128d __A, __m128d __B)
            .    .    .           .          .          .           .       .       .  {
2,724,878,712   40   19 161,465,496 30,211,797 22,636,812           0       0       0    return (__m128d) ((__v2df)__A + (__v2df)__B);
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_add_sd (__m128d __A, __m128d __B)
            .    .    .           .          .          .           .       .       .  {
    1,383,042    0    0           0          0          0           0       0       0    return (__m128d)__builtin_ia32_addsd ((__v2df)__A, (__v2df)__B);
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_sub_pd (__m128d __A, __m128d __B)
            .    .    .           .          .          .           .       .       .  {
  407,299,266    1    1 203,649,633 51,296,368 44,133,002           0       0       0    return (__m128d) ((__v2df)__A - (__v2df)__B);
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_sub_sd (__m128d __A, __m128d __B)
            .    .    .           .          .          .           .       .       .  {
            .    .    .           .          .          .           .       .       .    return (__m128d)__builtin_ia32_subsd ((__v2df)__A, (__v2df)__B);
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_mul_pd (__m128d __A, __m128d __B)
            .    .    .           .          .          .           .       .       .  {
4,298,123,061  112   55 867,434,271 76,968,420 62,886,664           0       0       0    return (__m128d) ((__v2df)__A * (__v2df)__B);
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_mul_sd (__m128d __A, __m128d __B)
            .    .    .           .          .          .           .       .       .  {
            .    .    .           .          .          .           .       .       .    return (__m128d)__builtin_ia32_mulsd ((__v2df)__A, (__v2df)__B);
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_div_pd (__m128d __A, __m128d __B)
            .    .    .           .          .          .           .       .       .  {
      694,978    0    0     347,489          0          0           0       0       0    return (__m128d) ((__v2df)__A / (__v2df)__B);
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_div_sd (__m128d __A, __m128d __B)
            .    .    .           .          .          .           .       .       .  {
            .    .    .           .          .          .           .       .       .    return (__m128d)__builtin_ia32_divsd ((__v2df)__A, (__v2df)__B);
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
-- line 292 ----------------------------------------
-- line 314 ----------------------------------------
            .    .    .           .          .          .           .       .       .  _mm_min_sd (__m128d __A, __m128d __B)
            .    .    .           .          .          .           .       .       .  {
            .    .    .           .          .          .           .       .       .    return (__m128d)__builtin_ia32_minsd ((__v2df)__A, (__v2df)__B);
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_max_pd (__m128d __A, __m128d __B)
            .    .    .           .          .          .           .       .       .  {
      699,040    1    1           0          0          0           0       0       0    return (__m128d)__builtin_ia32_maxpd ((__v2df)__A, (__v2df)__B);
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_max_sd (__m128d __A, __m128d __B)
            .    .    .           .          .          .           .       .       .  {
           10    0    0           0          0          0           0       0       0    return (__m128d)__builtin_ia32_maxsd ((__v2df)__A, (__v2df)__B);
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_and_pd (__m128d __A, __m128d __B)
            .    .    .           .          .          .           .       .       .  {
    1,747,625    0    0     699,060    174,399    146,401           0       0       0    return (__m128d)__builtin_ia32_andpd ((__v2df)__A, (__v2df)__B);
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_andnot_pd (__m128d __A, __m128d __B)
            .    .    .           .          .          .           .       .       .  {
            .    .    .           .          .          .           .       .       .    return (__m128d)__builtin_ia32_andnpd ((__v2df)__A, (__v2df)__B);
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
-- line 342 ----------------------------------------
-- line 926 ----------------------------------------
            .    .    .           .          .          .           .       .       .  #define _mm_shuffle_pd(A, B, N)						\
            .    .    .           .          .          .           .       .       .    ((__m128d)__builtin_ia32_shufpd ((__v2df)(__m128d)(A),		\
            .    .    .           .          .          .           .       .       .  				   (__v2df)(__m128d)(B), (int)(N)))
            .    .    .           .          .          .           .       .       .  #endif
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_unpackhi_pd (__m128d __A, __m128d __B)
            .    .    .           .          .          .           .       .       .  {
    3,447,104   42   22     681,000          0          0           0       0       0    return (__m128d)__builtin_ia32_unpckhpd ((__v2df)__A, (__v2df)__B);
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_unpacklo_pd (__m128d __A, __m128d __B)
            .    .    .           .          .          .           .       .       .  {
            .    .    .           .          .          .           .       .       .    return (__m128d)__builtin_ia32_unpcklpd ((__v2df)__A, (__v2df)__B);
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
-- line 942 ----------------------------------------
-- line 1426 ----------------------------------------
            .    .    .           .          .          .           .       .       .  _mm_shufflelo_epi16 (__m128i __A, const int __mask)
            .    .    .           .          .          .           .       .       .  {
            .    .    .           .          .          .           .       .       .    return (__m128i)__builtin_ia32_pshuflw ((__v8hi)__A, __mask);
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  
            .    .    .           .          .          .           .       .       .  extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
            .    .    .           .          .          .           .       .       .  _mm_shuffle_epi32 (__m128i __A, const int __mask)
            .    .    .           .          .          .           .       .       .  {
  920,350,080   48   24 920,350,080 90,515,096    893,328           0       0       0    return (__m128i)__builtin_ia32_pshufd ((__v4si)__A, __mask);
            .    .    .           .          .          .           .       .       .  }
            .    .    .           .          .          .           .       .       .  #else
            .    .    .           .          .          .           .       .       .  #define _mm_shufflehi_epi16(A, N) \
            .    .    .           .          .          .           .       .       .    ((__m128i)__builtin_ia32_pshufhw ((__v8hi)(__m128i)(A), (int)(N)))
            .    .    .           .          .          .           .       .       .  #define _mm_shufflelo_epi16(A, N) \
            .    .    .           .          .          .           .       .       .    ((__m128i)__builtin_ia32_pshuflw ((__v8hi)(__m128i)(A), (int)(N)))
            .    .    .           .          .          .           .       .       .  #define _mm_shuffle_epi32(A, N) \
            .    .    .           .          .          .           .       .       .    ((__m128i)__builtin_ia32_pshufd ((__v4si)(__m128i)(A), (int)(N)))
-- line 1442 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/renzo/repos/spack/opt/spack/linux-slackware14-core2/gcc-9.3.0/eigen-3.3.7-d3fwbpqkxuuxfzl43t63y74jaxvht3bx/include/eigen3/Eigen/src/Core/AssignEvaluator.h
--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr      D1mr    DLmr    Dw D1mw DLmw 

-- line 316 ----------------------------------------
          .    .    .       .       .       .  .    .    .  *** Default traversal ***
          .    .    .       .       .       .  .    .    .  ************************/
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .  template<typename Kernel>
          .    .    .       .       .       .  .    .    .  struct dense_assignment_loop<Kernel, DefaultTraversal, NoUnrolling>
          .    .    .       .       .       .  .    .    .  {
          .    .    .       .       .       .  .    .    .    EIGEN_DEVICE_FUNC static void EIGEN_STRONG_INLINE run(Kernel &kernel)
          .    .    .       .       .       .  .    .    .    {
         10   10    4       0       0       0  0    0    0      for(Index outer = 0; outer < kernel.outerSize(); ++outer) {
          .    .    .       .       .       .  .    .    .        for(Index inner = 0; inner < kernel.innerSize(); ++inner) {
          .    .    .       .       .       .  .    .    .          kernel.assignCoeffByOuterInner(outer, inner);
          .    .    .       .       .       .  .    .    .        }
          .    .    .       .       .       .  .    .    .      }
          .    .    .       .       .       .  .    .    .    }
          .    .    .       .       .       .  .    .    .  };
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .  template<typename Kernel>
-- line 332 ----------------------------------------
-- line 381 ----------------------------------------
          .    .    .       .       .       .  .    .    .                                      Index end)
          .    .    .       .       .       .  .    .    .  #else
          .    .    .       .       .       .  .    .    .    template <typename Kernel>
          .    .    .       .       .       .  .    .    .    EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel,
          .    .    .       .       .       .  .    .    .                                        Index start,
          .    .    .       .       .       .  .    .    .                                        Index end)
          .    .    .       .       .       .  .    .    .  #endif
          .    .    .       .       .       .  .    .    .    {
  7,432,265  102   43      16       5       2  0    0    0      for (Index index = start; index < end; ++index)
          .    .    .       .       .       .  .    .    .        kernel.assignCoeff(index);
          .    .    .       .       .       .  .    .    .    }
          .    .    .       .       .       .  .    .    .  };
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .  template<typename Kernel>
          .    .    .       .       .       .  .    .    .  struct dense_assignment_loop<Kernel, LinearVectorizedTraversal, NoUnrolling>
          .    .    .       .       .       .  .    .    .  {
          .    .    .       .       .       .  .    .    .    EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)
-- line 397 ----------------------------------------
-- line 403 ----------------------------------------
          .    .    .       .       .       .  .    .    .        requestedAlignment = Kernel::AssignmentTraits::LinearRequiredAlignment,
          .    .    .       .       .       .  .    .    .        packetSize = unpacket_traits<PacketType>::size,
          .    .    .       .       .       .  .    .    .        dstIsAligned = int(Kernel::AssignmentTraits::DstAlignment)>=int(requestedAlignment),
          .    .    .       .       .       .  .    .    .        dstAlignment = packet_traits<Scalar>::AlignedOnScalar ? int(requestedAlignment)
          .    .    .       .       .       .  .    .    .                                                              : int(Kernel::AssignmentTraits::DstAlignment),
          .    .    .       .       .       .  .    .    .        srcAlignment = Kernel::AssignmentTraits::JointAlignment
          .    .    .       .       .       .  .    .    .      };
          .    .    .       .       .       .  .    .    .      const Index alignedStart = dstIsAligned ? 0 : internal::first_aligned<requestedAlignment>(kernel.dstDataPtr(), size);
  7,765,154   20    9       0       0       0 10    0    0      const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .      unaligned_dense_assignment_loop<dstIsAligned!=0>::run(kernel, 0, alignedStart);
          .    .    .       .       .       .  .    .    .  
932,833,668   74   32       8       0       0 12    0    0      for(Index index = alignedStart; index < alignedEnd; index += packetSize)
          .    .    .       .       .       .  .    .    .        kernel.template assignPacket<dstAlignment, srcAlignment, PacketType>(index);
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .      unaligned_dense_assignment_loop<>::run(kernel, alignedEnd, size);
          .    .    .       .       .       .  .    .    .    }
          .    .    .       .       .       .  .    .    .  };
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .  template<typename Kernel>
          .    .    .       .       .       .  .    .    .  struct dense_assignment_loop<Kernel, LinearVectorizedTraversal, CompleteUnrolling>
-- line 423 ----------------------------------------
-- line 488 ----------------------------------------
          .    .    .       .       .       .  .    .    .  ***********************/
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .  template<typename Kernel>
          .    .    .       .       .       .  .    .    .  struct dense_assignment_loop<Kernel, LinearTraversal, NoUnrolling>
          .    .    .       .       .       .  .    .    .  {
          .    .    .       .       .       .  .    .    .    EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)
          .    .    .       .       .       .  .    .    .    {
          .    .    .       .       .       .  .    .    .      const Index size = kernel.size();
  2,839,467   55   24      10       2       0  0    0    0      for(Index i = 0; i < size; ++i)
          .    .    .       .       .       .  .    .    .        kernel.assignCoeff(i);
          .    .    .       .       .       .  .    .    .    }
          .    .    .       .       .       .  .    .    .  };
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .  template<typename Kernel>
          .    .    .       .       .       .  .    .    .  struct dense_assignment_loop<Kernel, LinearTraversal, CompleteUnrolling>
          .    .    .       .       .       .  .    .    .  {
          .    .    .       .       .       .  .    .    .    EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)
-- line 504 ----------------------------------------
-- line 523 ----------------------------------------
          .    .    .       .       .       .  .    .    .        packetSize = unpacket_traits<PacketType>::size,
          .    .    .       .       .       .  .    .    .        requestedAlignment = int(Kernel::AssignmentTraits::InnerRequiredAlignment),
          .    .    .       .       .       .  .    .    .        alignable = packet_traits<Scalar>::AlignedOnScalar || int(Kernel::AssignmentTraits::DstAlignment)>=sizeof(Scalar),
          .    .    .       .       .       .  .    .    .        dstIsAligned = int(Kernel::AssignmentTraits::DstAlignment)>=int(requestedAlignment),
          .    .    .       .       .       .  .    .    .        dstAlignment = alignable ? int(requestedAlignment)
          .    .    .       .       .       .  .    .    .                                 : int(Kernel::AssignmentTraits::DstAlignment)
          .    .    .       .       .       .  .    .    .      };
          .    .    .       .       .       .  .    .    .      const Scalar *dst_ptr = kernel.dstDataPtr();
         30    0    0       0       0       0  0    0    0      if((!bool(dstIsAligned)) && (UIntPtr(dst_ptr) % sizeof(Scalar))>0)
          .    .    .       .       .       .  .    .    .      {
          .    .    .       .       .       .  .    .    .        // the pointer is not aligend-on scalar, so alignment is not possible
          .    .    .       .       .       .  .    .    .        return dense_assignment_loop<Kernel,DefaultTraversal,NoUnrolling>::run(kernel);
          .    .    .       .       .       .  .    .    .      }
          .    .    .       .       .       .  .    .    .      const Index packetAlignedMask = packetSize - 1;
          .    .    .       .       .       .  .    .    .      const Index innerSize = kernel.innerSize();
          .    .    .       .       .       .  .    .    .      const Index outerSize = kernel.outerSize();
         42    0    0       0       0       0  8    0    0      const Index alignedStep = alignable ? (packetSize - kernel.outerStride() % packetSize) & packetAlignedMask : 0;
         10    0    0       0       0       0  2    0    0      Index alignedStart = ((!alignable) || bool(dstIsAligned)) ? 0 : internal::first_aligned<requestedAlignment>(dst_ptr, innerSize);
          .    .    .       .       .       .  .    .    .  
        164   15    8      46       0       0  0    0    0      for(Index outer = 0; outer < outerSize; ++outer)
          .    .    .       .       .       .  .    .    .      {
         62    0    0       0       0       0  2    0    0        const Index alignedEnd = alignedStart + ((innerSize-alignedStart) & ~packetAlignedMask);
          .    .    .       .       .       .  .    .    .        // do the non-vectorizable part of the assignment
         96    8    4      18       0       0 10    0    0        for(Index inner = 0; inner<alignedStart ; ++inner)
          .    .    .       .       .       .  .    .    .          kernel.assignCoeffByOuterInner(outer, inner);
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .        // do the vectorizable part of the assignment
        216    2    1      18       0       0 18    0    0        for(Index inner = alignedStart; inner<alignedEnd; inner+=packetSize)
          .    .    .       .       .       .  .    .    .          kernel.template assignPacketByOuterInner<dstAlignment, Unaligned, PacketType>(outer, inner);
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .        // do the non-vectorizable part of the assignment
         36    2    1       0       0       0  0    0    0        for(Index inner = alignedEnd; inner<innerSize ; ++inner)
          .    .    .       .       .       .  .    .    .          kernel.assignCoeffByOuterInner(outer, inner);
          .    .    .       .       .       .  .    .    .  
     68,616   30   15      18       0       0  0    0    0        alignedStart = numext::mini((alignedStart+alignedStep)%packetSize, innerSize);
          .    .    .       .       .       .  .    .    .      }
          .    .    .       .       .       .  .    .    .    }
          .    .    .       .       .       .  .    .    .  };
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .  #if EIGEN_UNALIGNED_VECTORIZE
          .    .    .       .       .       .  .    .    .  template<typename Kernel>
          .    .    .       .       .       .  .    .    .  struct dense_assignment_loop<Kernel, SliceVectorizedTraversal, InnerUnrolling>
          .    .    .       .       .       .  .    .    .  {
-- line 565 ----------------------------------------
-- line 623 ----------------------------------------
          .    .    .       .       .       .  .    .    .    EIGEN_DEVICE_FUNC Index outerStride() const { return m_dstExpr.outerStride(); }
          .    .    .       .       .       .  .    .    .    
          .    .    .       .       .       .  .    .    .    EIGEN_DEVICE_FUNC DstEvaluatorType& dstEvaluator() { return m_dst; }
          .    .    .       .       .       .  .    .    .    EIGEN_DEVICE_FUNC const SrcEvaluatorType& srcEvaluator() const { return m_src; }
          .    .    .       .       .       .  .    .    .    
          .    .    .       .       .       .  .    .    .    /// Assign src(row,col) to dst(row,col) through the assignment functor.
          .    .    .       .       .       .  .    .    .    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(Index row, Index col)
          .    .    .       .       .       .  .    .    .    {
      3,137    0    0   3,137   1,974   1,532  0    0    0      m_functor.assignCoeff(m_dst.coeffRef(row,col), m_src.coeff(row,col));
          .    .    .       .       .       .  .    .    .    }
          .    .    .       .       .       .  .    .    .    
          .    .    .       .       .       .  .    .    .    /// \sa assignCoeff(Index,Index)
          .    .    .       .       .       .  .    .    .    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(Index index)
          .    .    .       .       .       .  .    .    .    {
  1,049,210    0    0 700,834 697,009 487,705  0    0    0      m_functor.assignCoeff(m_dst.coeffRef(index), m_src.coeff(index));
          .    .    .       .       .       .  .    .    .    }
          .    .    .       .       .       .  .    .    .    
          .    .    .       .       .       .  .    .    .    /// \sa assignCoeff(Index,Index)
          .    .    .       .       .       .  .    .    .    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeffByOuterInner(Index outer, Index inner)
          .    .    .       .       .       .  .    .    .    {
          .    .    .       .       .       .  .    .    .      Index row = rowIndexByOuterInner(outer, inner); 
          .    .    .       .       .       .  .    .    .      Index col = colIndexByOuterInner(outer, inner); 
          .    .    .       .       .       .  .    .    .      assignCoeff(row, col);
-- line 645 ----------------------------------------
-- line 702 ----------------------------------------
          .    .    .       .       .       .  .    .    .  ***************************************************************************/
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .  template<typename DstXprType,typename SrcXprType, typename Functor>
          .    .    .       .       .       .  .    .    .  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
          .    .    .       .       .       .  .    .    .  void resize_if_allowed(DstXprType &dst, const SrcXprType& src, const Functor &/*func*/)
          .    .    .       .       .       .  .    .    .  {
          .    .    .       .       .       .  .    .    .    EIGEN_ONLY_USED_FOR_DEBUG(dst);
          .    .    .       .       .       .  .    .    .    EIGEN_ONLY_USED_FOR_DEBUG(src);
  2,808,328    9    4 704,112       0       0  0    0    0    eigen_assert(dst.rows() == src.rows() && dst.cols() == src.cols());
          .    .    .       .       .       .  .    .    .  }
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .  template<typename DstXprType,typename SrcXprType, typename T1, typename T2>
          .    .    .       .       .       .  .    .    .  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
         10    0    0       0       0       0  0    0    0  void resize_if_allowed(DstXprType &dst, const SrcXprType& src, const internal::assign_op<T1,T2> &/*func*/)
          .    .    .       .       .       .  .    .    .  {
          .    .    .       .       .       .  .    .    .    Index dstRows = src.rows();
          .    .    .       .       .       .  .    .    .    Index dstCols = src.cols();
      8,222    5    3      18       0       0 10    0    0    if(((dst.rows()!=dstRows) || (dst.cols()!=dstCols)))
          .    .    .       .       .       .  .    .    .      dst.resize(dstRows, dstCols);
          .    .    .       .       .       .  .    .    .    eigen_assert(dst.rows() == dstRows && dst.cols() == dstCols);
          .    .    .       .       .       .  .    .    .  }
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .  template<typename DstXprType, typename SrcXprType, typename Functor>
         38    5    3       0       0       0 30    0    0  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void call_dense_assignment_loop(DstXprType& dst, const SrcXprType& src, const Functor &func)
          .    .    .       .       .       .  .    .    .  {
          .    .    .       .       .       .  .    .    .    typedef evaluator<DstXprType> DstEvaluatorType;
          .    .    .       .       .       .  .    .    .    typedef evaluator<SrcXprType> SrcEvaluatorType;
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .    SrcEvaluatorType srcEvaluator(src);
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .    // NOTE To properly handle A = (A*A.transpose())/s with A rectangular,
          .    .    .       .       .       .  .    .    .    // we need to resize the destination after the source evaluator has been created.
-- line 733 ----------------------------------------
-- line 734 ----------------------------------------
          .    .    .       .       .       .  .    .    .    resize_if_allowed(dst, src, func);
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .    DstEvaluatorType dstEvaluator(dst);
          .    .    .       .       .       .  .    .    .      
          .    .    .       .       .       .  .    .    .    typedef generic_dense_assignment_kernel<DstEvaluatorType,SrcEvaluatorType,Functor> Kernel;
          .    .    .       .       .       .  .    .    .    Kernel kernel(dstEvaluator, srcEvaluator, func, dst.const_cast_derived());
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .    dense_assignment_loop<Kernel>::run(kernel);
         32    2    1      28       0       0  0    0    0  }
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .  template<typename DstXprType, typename SrcXprType>
          .    .    .       .       .       .  .    .    .  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void call_dense_assignment_loop(DstXprType& dst, const SrcXprType& src)
          .    .    .       .       .       .  .    .    .  {
          .    .    .       .       .       .  .    .    .    call_dense_assignment_loop(dst, src, internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar>());
          .    .    .       .       .       .  .    .    .  }
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .  /***************************************************************************
-- line 750 ----------------------------------------
-- line 828 ----------------------------------------
          .    .    .       .       .       .  .    .    .    typedef typename internal::conditional<NeedToTranspose, Transpose<Dst>, Dst&>::type ActualDstType;
          .    .    .       .       .       .  .    .    .    ActualDstType actualDst(dst);
          .    .    .       .       .       .  .    .    .    
          .    .    .       .       .       .  .    .    .    // TODO check whether this is the right place to perform these checks:
          .    .    .       .       .       .  .    .    .    EIGEN_STATIC_ASSERT_LVALUE(Dst)
          .    .    .       .       .       .  .    .    .    EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(ActualDstTypeCleaned,Src)
          .    .    .       .       .       .  .    .    .    EIGEN_CHECK_BINARY_COMPATIBILIY(Func,typename ActualDstTypeCleaned::Scalar,typename Src::Scalar);
          .    .    .       .       .       .  .    .    .    
         24    8    4       0       0       0  8    0    0    Assignment<ActualDstTypeCleaned,Src,Func>::run(actualDst, src, func);
          .    .    .       .       .       .  .    .    .  }
          .    .    .       .       .       .  .    .    .  template<typename Dst, typename Src>
          .    .    .       .       .       .  .    .    .  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
          .    .    .       .       .       .  .    .    .  void call_assignment_no_alias(Dst& dst, const Src& src)
          .    .    .       .       .       .  .    .    .  {
          .    .    .       .       .       .  .    .    .    call_assignment_no_alias(dst, src, internal::assign_op<typename Dst::Scalar,typename Src::Scalar>());
          .    .    .       .       .       .  .    .    .  }
          .    .    .       .       .       .  .    .    .  
-- line 844 ----------------------------------------
-- line 871 ----------------------------------------
          .    .    .       .       .       .  .    .    .  {
          .    .    .       .       .       .  .    .    .    EIGEN_DEVICE_FUNC
          .    .    .       .       .       .  .    .    .    static EIGEN_STRONG_INLINE void run(DstXprType &dst, const SrcXprType &src, const Functor &func)
          .    .    .       .       .       .  .    .    .    {
          .    .    .       .       .       .  .    .    .  #ifndef EIGEN_NO_DEBUG
          .    .    .       .       .       .  .    .    .      internal::check_for_aliasing(dst, src);
          .    .    .       .       .       .  .    .    .  #endif
          .    .    .       .       .       .  .    .    .      
         24    0    0       4       0       0  4    0    0      call_dense_assignment_loop(dst, src, func);
          .    .    .       .       .       .  .    .    .    }
          .    .    .       .       .       .  .    .    .  };
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .  // Generic assignment through evalTo.
          .    .    .       .       .       .  .    .    .  // TODO: not sure we have to keep that one, but it helps porting current code to new evaluator mechanism.
          .    .    .       .       .       .  .    .    .  // Note that the last template argument "Weak" is needed to make it possible to perform
          .    .    .       .       .       .  .    .    .  // both partial specialization+SFINAE without ambiguous specialization
          .    .    .       .       .       .  .    .    .  template< typename DstXprType, typename SrcXprType, typename Functor, typename Weak>
          .    .    .       .       .       .  .    .    .  struct Assignment<DstXprType, SrcXprType, Functor, EigenBase2EigenBase, Weak>
          .    .    .       .       .       .  .    .    .  {
          .    .    .       .       .       .  .    .    .    EIGEN_DEVICE_FUNC
          .    .    .       .       .       .  .    .    .    static EIGEN_STRONG_INLINE void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &/*func*/)
          .    .    .       .       .       .  .    .    .    {
          .    .    .       .       .       .  .    .    .      Index dstRows = src.rows();
          .    .    .       .       .       .  .    .    .      Index dstCols = src.cols();
         20    0    0       0       0       0  0    0    0      if((dst.rows()!=dstRows) || (dst.cols()!=dstCols))
          .    .    .       .       .       .  .    .    .        dst.resize(dstRows, dstCols);
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .      eigen_assert(dst.rows() == src.rows() && dst.cols() == src.cols());
          .    .    .       .       .       .  .    .    .      src.evalTo(dst);
          .    .    .       .       .       .  .    .    .    }
          .    .    .       .       .       .  .    .    .  
          .    .    .       .       .       .  .    .    .    // NOTE The following two functions are templated to avoid their instanciation if not needed
          .    .    .       .       .       .  .    .    .    //      This is needed because some expressions supports evalTo only and/or have 'void' as scalar type.
-- line 903 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/renzo/repos/spack/opt/spack/linux-slackware14-core2/gcc-9.3.0/eigen-3.3.7-d3fwbpqkxuuxfzl43t63y74jaxvht3bx/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h
--------------------------------------------------------------------------------
Ir        I1mr ILmr Dr        D1mr    DLmr   Dw        D1mw DLmw 

-- line 157 ----------------------------------------
        .    .    .         .       .      .         .    .    .        *
        .    .    .         .       .      .         .    .    .        * \sa compute(const MatrixType&, int)
        .    .    .         .       .      .         .    .    .        */
        .    .    .         .       .      .         .    .    .      template<typename InputType>
        .    .    .         .       .      .         .    .    .      EIGEN_DEVICE_FUNC
        .    .    .         .       .      .         .    .    .      explicit SelfAdjointEigenSolver(const EigenBase<InputType>& matrix, int options = ComputeEigenvectors)
        .    .    .         .       .      .         .    .    .        : m_eivec(matrix.rows(), matrix.cols()),
        .    .    .         .       .      .         .    .    .          m_eivalues(matrix.cols()),
       30    0    0         0       0      0         0    0    0          m_subdiag(matrix.rows() > 1 ? matrix.rows() - 1 : 1),
       10    0    0         0       0      0        10    0    0          m_isInitialized(false)
        .    .    .         .       .      .         .    .    .      {
       40    0    0         0       0      0        10    0    0        compute(matrix.derived(), options);
        .    .    .         .       .      .         .    .    .      }
        .    .    .         .       .      .         .    .    .  
        .    .    .         .       .      .         .    .    .      /** \brief Computes eigendecomposition of given matrix.
        .    .    .         .       .      .         .    .    .        *
        .    .    .         .       .      .         .    .    .        * \param[in]  matrix  Selfadjoint matrix whose eigendecomposition is to
        .    .    .         .       .      .         .    .    .        *    be computed. Only the lower triangular part of the matrix is referenced.
        .    .    .         .       .      .         .    .    .        * \param[in]  options Can be #ComputeEigenvectors (default) or #EigenvaluesOnly.
        .    .    .         .       .      .         .    .    .        * \returns    Reference to \c *this
-- line 176 ----------------------------------------
-- line 276 ----------------------------------------
        .    .    .         .       .      .         .    .    .        * Example: \include SelfAdjointEigenSolver_eigenvalues.cpp
        .    .    .         .       .      .         .    .    .        * Output: \verbinclude SelfAdjointEigenSolver_eigenvalues.out
        .    .    .         .       .      .         .    .    .        *
        .    .    .         .       .      .         .    .    .        * \sa eigenvectors(), MatrixBase::eigenvalues()
        .    .    .         .       .      .         .    .    .        */
        .    .    .         .       .      .         .    .    .      EIGEN_DEVICE_FUNC
        .    .    .         .       .      .         .    .    .      const RealVectorType& eigenvalues() const
        .    .    .         .       .      .         .    .    .      {
       20   19    7        10       0      0         0    0    0        eigen_assert(m_isInitialized && "SelfAdjointEigenSolver is not initialized.");
        .    .    .         .       .      .         .    .    .        return m_eivalues;
        .    .    .         .       .      .         .    .    .      }
        .    .    .         .       .      .         .    .    .  
        .    .    .         .       .      .         .    .    .      /** \brief Computes the positive-definite square root of the matrix.
        .    .    .         .       .      .         .    .    .        *
        .    .    .         .       .      .         .    .    .        * \returns the positive-definite square root of the matrix
        .    .    .         .       .      .         .    .    .        *
        .    .    .         .       .      .         .    .    .        * \pre The eigenvalues and eigenvectors of a positive-definite matrix
-- line 292 ----------------------------------------
-- line 391 ----------------------------------------
        .    .    .         .       .      .         .    .    .  template<int StorageOrder,typename RealScalar, typename Scalar, typename Index>
        .    .    .         .       .      .         .    .    .  EIGEN_DEVICE_FUNC
        .    .    .         .       .      .         .    .    .  static void tridiagonal_qr_step(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n);
        .    .    .         .       .      .         .    .    .  }
        .    .    .         .       .      .         .    .    .  
        .    .    .         .       .      .         .    .    .  template<typename MatrixType>
        .    .    .         .       .      .         .    .    .  template<typename InputType>
        .    .    .         .       .      .         .    .    .  EIGEN_DEVICE_FUNC
       70   10    4         0       0      0        60    0    0  SelfAdjointEigenSolver<MatrixType>& SelfAdjointEigenSolver<MatrixType>
        .    .    .         .       .      .         .    .    .  ::compute(const EigenBase<InputType>& a_matrix, int options)
        .    .    .         .       .      .         .    .    .  {
        .    .    .         .       .      .         .    .    .    check_template_parameters();
        .    .    .         .       .      .         .    .    .    
        .    .    .         .       .      .         .    .    .    const InputType &matrix(a_matrix.derived());
        .    .    .         .       .      .         .    .    .    
        .    .    .         .       .      .         .    .    .    using std::abs;
       20    0    0        10       0      0         0    0    0    eigen_assert(matrix.cols() == matrix.rows());
       60   10    4         0       0      0         0    0    0    eigen_assert((options&~(EigVecMask|GenEigMask))==0
        .    .    .         .       .      .         .    .    .            && (options&EigVecMask)!=EigVecMask
        .    .    .         .       .      .         .    .    .            && "invalid option parameter");
       30    0    0         0       0      0        10    0    0    bool computeEigenvectors = (options&ComputeEigenvectors)==ComputeEigenvectors;
        .    .    .         .       .      .         .    .    .    Index n = matrix.cols();
        .    .    .         .       .      .         .    .    .    m_eivalues.resize(n,1);
        .    .    .         .       .      .         .    .    .  
       20    0    0         0       0      0         0    0    0    if(n==1)
        .    .    .         .       .      .         .    .    .    {
        .    .    .         .       .      .         .    .    .      m_eivec = matrix;
        .    .    .         .       .      .         .    .    .      m_eivalues.coeffRef(0,0) = numext::real(m_eivec.coeff(0,0));
        .    .    .         .       .      .         .    .    .      if(computeEigenvectors)
        .    .    .         .       .      .         .    .    .        m_eivec.setOnes(n,n);
        .    .    .         .       .      .         .    .    .      m_info = Success;
        .    .    .         .       .      .         .    .    .      m_isInitialized = true;
        .    .    .         .       .      .         .    .    .      m_eigenvectorsOk = computeEigenvectors;
-- line 423 ----------------------------------------
-- line 426 ----------------------------------------
        .    .    .         .       .      .         .    .    .  
        .    .    .         .       .      .         .    .    .    // declare some aliases
        .    .    .         .       .      .         .    .    .    RealVectorType& diag = m_eivalues;
        .    .    .         .       .      .         .    .    .    EigenvectorsType& mat = m_eivec;
        .    .    .         .       .      .         .    .    .  
        .    .    .         .       .      .         .    .    .    // map the matrix coefficients to [-1:1] to avoid over- and underflow.
        .    .    .         .       .      .         .    .    .    mat = matrix.template triangularView<Lower>();
        .    .    .         .       .      .         .    .    .    RealScalar scale = mat.cwiseAbs().maxCoeff();
       30    0    0        10       6      3         0    0    0    if(scale==RealScalar(0)) scale = RealScalar(1);
        .    .    .         .       .      .         .    .    .    mat.template triangularView<Lower>() /= scale;
       10    0    0         0       0      0         0    0    0    m_subdiag.resize(n-1);
       10    0    0        10       5      2         0    0    0    internal::tridiagonalization_inplace(mat, diag, m_subdiag, computeEigenvectors);
        .    .    .         .       .      .         .    .    .  
       70    0    0         0       0      0        20    0    0    m_info = internal::computeFromTridiagonal_impl(diag, m_subdiag, m_maxIterations, computeEigenvectors, m_eivec);
        .    .    .         .       .      .         .    .    .    
        .    .    .         .       .      .         .    .    .    // scale back the eigen values
        .    .    .         .       .      .         .    .    .    m_eivalues *= scale;
        .    .    .         .       .      .         .    .    .  
       10    0    0         0       0      0        10    0    0    m_isInitialized = true;
       20   10    4        10       0      0        10    0    0    m_eigenvectorsOk = computeEigenvectors;
        .    .    .         .       .      .         .    .    .    return *this;
      198   14    6        70      10      4         0    0    0  }
        .    .    .         .       .      .         .    .    .  
        .    .    .         .       .      .         .    .    .  template<typename MatrixType>
        .    .    .         .       .      .         .    .    .  SelfAdjointEigenSolver<MatrixType>& SelfAdjointEigenSolver<MatrixType>
        .    .    .         .       .      .         .    .    .  ::computeFromTridiagonal(const RealVectorType& diag, const SubDiagonalType& subdiag , int options)
        .    .    .         .       .      .         .    .    .  {
        .    .    .         .       .      .         .    .    .    //TODO : Add an option to scale the values beforehand
        .    .    .         .       .      .         .    .    .    bool computeEigenvectors = (options&ComputeEigenvectors)==ComputeEigenvectors;
        .    .    .         .       .      .         .    .    .  
-- line 455 ----------------------------------------
-- line 474 ----------------------------------------
        .    .    .         .       .      .         .    .    .    * \param[in,out] diag : On input, the diagonal of the matrix, on output the eigenvalues
        .    .    .         .       .      .         .    .    .    * \param[in,out] subdiag : The subdiagonal part of the matrix (entries are modified during the decomposition)
        .    .    .         .       .      .         .    .    .    * \param[in] maxIterations : the maximum number of iterations
        .    .    .         .       .      .         .    .    .    * \param[in] computeEigenvectors : whether the eigenvectors have to be computed or not
        .    .    .         .       .      .         .    .    .    * \param[out] eivec : The matrix to store the eigenvectors if computeEigenvectors==true. Must be allocated on input.
        .    .    .         .       .      .         .    .    .    * \returns \c Success or \c NoConvergence
        .    .    .         .       .      .         .    .    .    */
        .    .    .         .       .      .         .    .    .  template<typename MatrixType, typename DiagType, typename SubDiagType>
      110   10    4         0       0      0       100    0    0  ComputationInfo computeFromTridiagonal_impl(DiagType& diag, SubDiagType& subdiag, const Index maxIterations, bool computeEigenvectors, MatrixType& eivec)
        .    .    .         .       .      .         .    .    .  {
        .    .    .         .       .      .         .    .    .    using std::abs;
        .    .    .         .       .      .         .    .    .  
        .    .    .         .       .      .         .    .    .    ComputationInfo info;
        .    .    .         .       .      .         .    .    .    typedef typename MatrixType::Scalar Scalar;
        .    .    .         .       .      .         .    .    .  
        .    .    .         .       .      .         .    .    .    Index n = diag.size();
       20    0    0         0       0      0        10    0    0    Index end = n-1;
    3,104    0    0         0       0      0         0    0    0    Index start = 0;
       10    0    0         0       0      0        10    0    0    Index iter = 0; // total number of iterations
        .    .    .         .       .      .         .    .    .    
        .    .    .         .       .      .         .    .    .    typedef typename DiagType::RealScalar RealScalar;
        .    .    .         .       .      .         .    .    .    const RealScalar considerAsZero = (std::numeric_limits<RealScalar>::min)();
        .    .    .         .       .      .         .    .    .    const RealScalar precision = RealScalar(2)*NumTraits<RealScalar>::epsilon();
        .    .    .         .       .      .         .    .    .    
       30   10    4         0       0      0         0    0    0    while (end>0)
        .    .    .         .       .      .         .    .    .    {
2,387,402    0    0         0       0      0         0    0    0      for (Index i = start; i<end; ++i)
8,333,236    0    0     3,094       0      0         0    0    0        if (internal::isMuchSmallerThan(abs(subdiag[i]),(abs(diag[i])+abs(diag[i+1])),precision) || abs(subdiag[i]) <= considerAsZero)
    2,036    0    0         0       0      0     2,036    0    0          subdiag[i] = 0;
        .    .    .         .       .      .         .    .    .  
        .    .    .         .       .      .         .    .    .      // find the largest unreduced block
   42,028   10    4     5,120       0      0         0    0    0      while (end>0 && subdiag[end-1]==RealScalar(0))
        .    .    .         .       .      .         .    .    .      {
        .    .    .         .       .      .         .    .    .        end--;
        .    .    .         .       .      .         .    .    .      }
        .    .    .         .       .      .         .    .    .      if (end<=0)
        .    .    .         .       .      .         .    .    .        break;
        .    .    .         .       .      .         .    .    .  
        .    .    .         .       .      .         .    .    .      // if we spent too many iterations, we give up
    6,168    9    3     6,168       0      0         0    0    0      iter++;
    6,218   19    8     3,084       0      0        30    0    0      if(iter > maxIterations * n) break;
        .    .    .         .       .      .         .    .    .  
        .    .    .         .       .      .         .    .    .      start = end - 1;
8,305,482    0    0 1,185,717      22      0         0    0    0      while (start>0 && subdiag[start-1]!=0)
        .    .    .         .       .      .         .    .    .        start--;
        .    .    .         .       .      .         .    .    .  
    9,252    0    0     3,084       0      0     3,084    0    0      internal::tridiagonal_qr_step<MatrixType::Flags&RowMajorBit ? RowMajor : ColMajor>(diag.data(), subdiag.data(), start, end, computeEigenvectors ? eivec.data() : (Scalar*)0, n);
        .    .    .         .       .      .         .    .    .    }
       70    0    0        20       0      0         0    0    0    if (iter <= maxIterations * n)
       10    0    0         0       0      0         0    0    0      info = Success;
        .    .    .         .       .      .         .    .    .    else
        .    .    .         .       .      .         .    .    .      info = NoConvergence;
        .    .    .         .       .      .         .    .    .  
        .    .    .         .       .      .         .    .    .    // Sort eigenvalues and corresponding vectors.
        .    .    .         .       .      .         .    .    .    // TODO make the sort optional ?
        .    .    .         .       .      .         .    .    .    // TODO use a better sort algorithm !!
        .    .    .         .       .      .         .    .    .    if (info == Success)
        .    .    .         .       .      .         .    .    .    {
    8,144    1    1     2,036       0      0         0    0    0      for (Index i = 0; i < n-1; ++i)
        .    .    .         .       .      .         .    .    .      {
        .    .    .         .       .      .         .    .    .        Index k;
        .    .    .         .       .      .         .    .    .        diag.segment(i,n-i).minCoeff(&k);
    4,072    0    0         0       0      0         0    0    0        if (k > 0)
        .    .    .         .       .      .         .    .    .        {
    1,938    1    1         0       0      0         0    0    0          std::swap(diag[i], diag[k+i]);
    3,876    0    0     1,938       0      0         0    0    0          if(computeEigenvectors)
        .    .    .         .       .      .         .    .    .            eivec.col(i).swap(eivec.col(k+i));
        .    .    .         .       .      .         .    .    .        }
        .    .    .         .       .      .         .    .    .      }
        .    .    .         .       .      .         .    .    .    }
        .    .    .         .       .      .         .    .    .    return info;
       80    0    0        70       5      2         0    0    0  }
        .    .    .         .       .      .         .    .    .    
        .    .    .         .       .      .         .    .    .  template<typename SolverType,int Size,bool IsComplex> struct direct_selfadjoint_eigenvalues
        .    .    .         .       .      .         .    .    .  {
        .    .    .         .       .      .         .    .    .    EIGEN_DEVICE_FUNC
        .    .    .         .       .      .         .    .    .    static inline void run(SolverType& eig, const typename SolverType::MatrixType& A, int options)
        .    .    .         .       .      .         .    .    .    { eig.compute(A,options); }
        .    .    .         .       .      .         .    .    .  };
        .    .    .         .       .      .         .    .    .  
-- line 553 ----------------------------------------
-- line 803 ----------------------------------------
        .    .    .         .       .      .         .    .    .  }
        .    .    .         .       .      .         .    .    .  
        .    .    .         .       .      .         .    .    .  namespace internal {
        .    .    .         .       .      .         .    .    .  template<int StorageOrder,typename RealScalar, typename Scalar, typename Index>
        .    .    .         .       .      .         .    .    .  EIGEN_DEVICE_FUNC
        .    .    .         .       .      .         .    .    .  static void tridiagonal_qr_step(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n)
        .    .    .         .       .      .         .    .    .  {
        .    .    .         .       .      .         .    .    .    using std::abs;
   21,588    9    4    12,336     309    306         0    0    0    RealScalar td = (diag[end-1] - diag[end])*RealScalar(0.5);
    3,084    0    0     3,084       0      0         0    0    0    RealScalar e = subdiag[end-1];
        .    .    .         .       .      .         .    .    .    // Note that thanks to scaling, e^2 or td^2 cannot overflow, however they can still
        .    .    .         .       .      .         .    .    .    // underflow thus leading to inf/NaN values when using the following commented code:
        .    .    .         .       .      .         .    .    .  //   RealScalar e2 = numext::abs2(subdiag[end-1]);
        .    .    .         .       .      .         .    .    .  //   RealScalar mu = diag[end] - e2 / (td + (td>0 ? 1 : -1) * sqrt(td*td + e2));
        .    .    .         .       .      .         .    .    .    // This explain the following, somewhat more complicated, version:
        .    .    .         .       .      .         .    .    .    RealScalar mu = diag[end];
    9,252    0    0         0       0      0         0    0    0    if(td==RealScalar(0))
        .    .    .         .       .      .         .    .    .      mu -= abs(e);
        .    .    .         .       .      .         .    .    .    else
        .    .    .         .       .      .         .    .    .    {
        .    .    .         .       .      .         .    .    .      RealScalar e2 = numext::abs2(subdiag[end-1]);
        .    .    .         .       .      .         .    .    .      RealScalar h = numext::hypot(td,e);
    9,252    0    0         0       0      0         0    0    0      if(e2==RealScalar(0)) mu -= (e / (td + (td>RealScalar(0) ? RealScalar(1) : RealScalar(-1)))) * (e / h);
   19,819    6    3     1,315     107    105         0    0    0      else                  mu -= e2 / (td + (td>RealScalar(0) ? h : -h));
        .    .    .         .       .      .         .    .    .    }
        .    .    .         .       .      .         .    .    .    
   12,336    0    0     3,084       1      0         0    0    0    RealScalar x = diag[start] - mu;
    3,084    0    0     3,084       0      0         0    0    0    RealScalar z = subdiag[start];
4,806,692   15    8 2,392,552       0      0    12,336    0    0    for (Index k = start; k < end; ++k)
        .    .    .         .       .      .         .    .    .    {
        .    .    .         .       .      .         .    .    .      JacobiRotation<RealScalar> rot;
        .    .    .         .       .      .         .    .    .      rot.makeGivens(x, z);
        .    .    .         .       .      .         .    .    .  
        .    .    .         .       .      .         .    .    .      // do T = G' T G
8,319,962    9    4 2,377,132       0      0         0    0    0      RealScalar sdk = rot.s() * diag[k] + rot.c() * subdiag[k];
5,942,830    7    4 1,188,566 146,252 70,616         0    0    0      RealScalar dkp1 = rot.s() * subdiag[k] + rot.c() * diag[k+1];
        .    .    .         .       .      .         .    .    .  
9,508,528    0    0         0       0      0 1,188,566    0    0      diag[k] = rot.c() * (rot.c() * diag[k] - rot.s() * subdiag[k]) - rot.s() * (rot.c() * subdiag[k] - rot.s() * diag[k+1]);
7,131,396    9    4         0       0      0 1,188,566    0    0      diag[k+1] = rot.s() * sdk + rot.c() * dkp1;
4,754,264    0    0         0       0      0 1,188,566    0    0      subdiag[k] = rot.c() * sdk - rot.s() * dkp1;
        .    .    .         .       .      .         .    .    .      
        .    .    .         .       .      .         .    .    .  
2,377,132    0    0 1,188,566       0      0         0    0    0      if (k > start)
7,112,892    0    0 1,185,482       0      0 1,185,482    0    0        subdiag[k - 1] = rot.c() * subdiag[k-1] - rot.s() * z;
        .    .    .         .       .      .         .    .    .  
        .    .    .         .       .      .         .    .    .      x = subdiag[k];
        .    .    .         .       .      .         .    .    .  
2,377,132    9    4 1,188,566       0      0         0    0    0      if (k < end - 1)
        .    .    .         .       .      .         .    .    .      {
4,741,928    0    0 2,370,964 145,385 69,572         0    0    0        z = -rot.s() * subdiag[k+1];
2,370,964    0    0         0       0      0 1,185,482    0    0        subdiag[k + 1] = rot.c() * subdiag[k+1];
        .    .    .         .       .      .         .    .    .      }
        .    .    .         .       .      .         .    .    .      
        .    .    .         .       .      .         .    .    .      // apply the givens rotation to the unit matrix Q = Q * G
3,565,698    9    4 1,188,566       0      0         0    0    0      if (matrixQ)
        .    .    .         .       .      .         .    .    .      {
        .    .    .         .       .      .         .    .    .        // FIXME if StorageOrder == RowMajor this operation is not very efficient
        .    .    .         .       .      .         .    .    .        Map<Matrix<Scalar,Dynamic,Dynamic,StorageOrder> > q(matrixQ,n,n);
        .    .    .         .       .      .         .    .    .        q.applyOnTheRight(k,k+1,rot);
        .    .    .         .       .      .         .    .    .      }
        .    .    .         .       .      .         .    .    .    }
        .    .    .         .       .      .         .    .    .  }
        .    .    .         .       .      .         .    .    .  
-- line 865 ----------------------------------------

--------------------------------------------------------------------------------
Ir             I1mr  ILmr  Dr            D1mr        DLmr        Dw            D1mw      DLmw    
--------------------------------------------------------------------------------
19,390,085,781 2,387 1,103 3,794,754,907 424,878,561 242,525,427 1,460,753,897 1,361,468 934,421  events annotated

